from collections import OrderedDict
from contextlib import ExitStack
import inspect
import itertools
import logging
import math
from numbers import Real
from operator import attrgetter
import types

import numpy as np

import matplotlib as mpl
from matplotlib import _api
$$$$$$$,
$$$$$$$ cbook
from matplotlib.cbook import _OrderedSet
$$$$$$$,
$$$$$$$ _check_1d
$$$$$$$,
$$$$$$$ index_of
from matplotlib import docstring
import matplotlib.colors as mcolors
import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import matplotlib.artist as martist
import matplotlib.transforms as mtransforms
import matplotlib.ticker as mticker
import matplotlib.axis as maxis
import matplotlib.spines as mspines
import matplotlib.font_manager as font_manager
import matplotlib.text as mtext
import matplotlib.image as mimage
from matplotlib.rcsetup import cycler
$$$$$$$,
$$$$$$$ validate_axisbelow

_log = logging.getLogger
$$$$$$$(
$$$$$$$__name__
$$$$$$$)
$$$$$$$


class _axis_method_wrapper
$$$$$$$:
$$$$$$$
$$$$$$$
    """
    Helper to generate Axes methods wrapping Axis methods.
$$$$$$$

$$$$$$$
    After 
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
        get_foo = _axis_method_wrapper
$$$$$$$
$$$$$$$(
$$$$$$$"xaxis"
$$$$$$$,
$$$$$$$ "get_bar"
$$$$$$$)
$$$$$$$

$$$$$$$
    
$$$$$$$
$$$$$$$(
$$$$$$$in the body of a class
$$$$$$$)
$$$$$$$ ``get_foo`` is a method that forwards it arguments
$$$$$$$
    to the ``get_bar`` method of the ``xaxis`` attribute
$$$$$$$
$$$$$$$,
$$$$$$$ and gets its
$$$$$$$
    signature and docstring from ``Axis.get_bar``.
$$$$$$$

$$$$$$$
    The docstring of ``get_foo`` is built by replacing "this Axis" by "the
    {attr_name}" 
$$$$$$$
$$$$$$$(
$$$$$$$i.e.
$$$$$$$,
$$$$$$$ "the xaxis"
$$$$$$$,
$$$$$$$ "the yaxis"
$$$$$$$)
$$$$$$$ in the wrapped method's
$$$$$$$
    dedented docstring; additional replacements can by given in *doc_sub*.
    """
$$$$$$$

$$$$$$$
    def __init__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ attr_name
$$$$$$$,
$$$$$$$ method_name
$$$$$$$,
$$$$$$$ *
$$$$$$$,
$$$$$$$ doc_sub=None
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        self.attr_name = attr_name
        self.method_name = method_name
        # Immediately put the docstring in ``self.__doc__`` so that docstring
        # manipulations within the class body work as expected.
        doc = inspect.getdoc
$$$$$$$
$$$$$$$(
$$$$$$$getattr
$$$$$$$(
$$$$$$$maxis.Axis
$$$$$$$,
$$$$$$$ method_name
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self._missing_subs = []
        if doc
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            doc_sub = {"this Axis"
$$$$$$$
$$$$$$$:
$$$$$$$ f"the {self.attr_name}"
$$$$$$$,
$$$$$$$ **
$$$$$$$(
$$$$$$$doc_sub or {}
$$$$$$$)
$$$$$$$}
$$$$$$$
            for k
$$$$$$$
$$$$$$$,
$$$$$$$ v in doc_sub.items
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                if k not in doc
$$$$$$$
$$$$$$$:
$$$$$$$  # Delay raising error until we know qualname.
$$$$$$$
                    self._missing_subs.append
$$$$$$$
$$$$$$$(
$$$$$$$k
$$$$$$$)
$$$$$$$
$$$$$$$
                doc = doc.replace
$$$$$$$
$$$$$$$(
$$$$$$$k
$$$$$$$,
$$$$$$$ v
$$$$$$$)
$$$$$$$
$$$$$$$
        self.__doc__ = doc
$$$$$$$

$$$$$$$
    def __set_name__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ owner
$$$$$$$,
$$$$$$$ name
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # This is called at the end of the class body as
        # ``self.__set_name__
$$$$$$$
$$$$$$$(
$$$$$$$cls
$$$$$$$,
$$$$$$$ name_under_which_self_is_assigned
$$$$$$$)
$$$$$$$``; we
$$$$$$$
        # rely on that to give the wrapper the correct __name__/__qualname__.
        get_method = attrgetter
$$$$$$$
$$$$$$$(
$$$$$$$f"{self.attr_name}.{self.method_name}"
$$$$$$$)
$$$$$$$

$$$$$$$
        def wrapper
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ *args
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return get_method
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$(
$$$$$$$*args
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$

$$$$$$$
        wrapper.__module__ = owner.__module__
        wrapper.__name__ = name
        wrapper.__qualname__ = f"{owner.__qualname__}.{name}"
        wrapper.__doc__ = self.__doc__
        # Manually copy the signature instead of using functools.wraps because
        # displaying the Axis method source when asking for the Axes method
        # source would be confusing.
        wrapper.__signature__ = inspect.signature
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            getattr
$$$$$$$
$$$$$$$(
$$$$$$$maxis.Axis
$$$$$$$,
$$$$$$$ self.method_name
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        if self._missing_subs
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                "The definition of {} expected that the docstring of Axis.{} "
                "contains {!r} as substrings".format
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                    wrapper.__qualname__
$$$$$$$
$$$$$$$,
$$$$$$$ self.method_name
$$$$$$$,
$$$$$$$
$$$$$$$
                    "
$$$$$$$
$$$$$$$,
$$$$$$$ ".join
$$$$$$$(
$$$$$$$map
$$$$$$$(
$$$$$$$repr
$$$$$$$,
$$$$$$$ self._missing_subs
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        setattr
$$$$$$$
$$$$$$$(
$$$$$$$owner
$$$$$$$,
$$$$$$$ name
$$$$$$$,
$$$$$$$ wrapper
$$$$$$$)
$$$$$$$


class _TransformedBoundsLocator
$$$$$$$:
$$$$$$$
$$$$$$$
    """
    Axes locator for `.Axes.inset_axes` and similarly positioned axes.
$$$$$$$

$$$$$$$
    The locator is a callable object used in `.Axes.set_aspect` to compute the
    axes location depending on the renderer.
    """
$$$$$$$

$$$$$$$
    def __init__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ bounds
$$$$$$$,
$$$$$$$ transform
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        *bounds* 
$$$$$$$
$$$$$$$(
$$$$$$$a ``[l
$$$$$$$,
$$$$$$$ b
$$$$$$$,
$$$$$$$ w
$$$$$$$,
$$$$$$$ h]`` rectangle
$$$$$$$)
$$$$$$$ and *transform* together
$$$$$$$
        specify the position of the inset axes.
        """
        self._bounds = bounds
        self._transform = transform
$$$$$$$

$$$$$$$
    def __call__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ ax
$$$$$$$,
$$$$$$$ renderer
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # Subtracting transFigure will typically rely on inverted
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ freezing
$$$$$$$
        # the transform; thus
$$$$$$$
$$$$$$$,
$$$$$$$ this needs to be delayed until draw time as
$$$$$$$
        # transFigure may otherwise change after this is evaluated.
        return mtransforms.TransformedBbox
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            mtransforms.Bbox.from_bounds
$$$$$$$
$$$$$$$(
$$$$$$$*self._bounds
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            self._transform - ax.figure.transFigure
$$$$$$$
$$$$$$$)
$$$$$$$


def _process_plot_format
$$$$$$$(
$$$$$$$fmt
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
    """
    Convert a MATLAB style color/line style format string to a 
$$$$$$$
$$$$$$$(
$$$$$$$*linestyle*
$$$$$$$,
$$$$$$$
$$$$$$$
    *marker*
$$$$$$$
$$$$$$$,
$$$$$$$ *color*
$$$$$$$)
$$$$$$$ tuple.

$$$$$$$
    Example format strings include
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
    * 'ko'
$$$$$$$
$$$$$$$:
$$$$$$$ black circles
$$$$$$$
    * '.b'
$$$$$$$
$$$$$$$:
$$$$$$$ blue dots
$$$$$$$
    * 'r--'
$$$$$$$
$$$$$$$:
$$$$$$$ red dashed lines
$$$$$$$
    * 'C2--'
$$$$$$$
$$$$$$$:
$$$$$$$ the third color in the color cycle
$$$$$$$,
$$$$$$$ dashed lines

$$$$$$$
    See Also
    --------
    matplotlib.Line2D.lineStyles
$$$$$$$
$$$$$$$,
$$$$$$$ matplotlib.colors.cnames
$$$$$$$
        All possible styles and color format strings.
$$$$$$$
    """
$$$$$$$

$$$$$$$
    linestyle = None
    marker = None
    color = None
$$$$$$$

$$$$$$$
    # Is fmt just a colorspec?
    try
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        color = mcolors.to_rgba
$$$$$$$
$$$$$$$(
$$$$$$$fmt
$$$$$$$)
$$$$$$$

$$$$$$$
        # We need to differentiate grayscale '1.0' from tri_down marker '1'
        try
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            fmtint = str
$$$$$$$
$$$$$$$(
$$$$$$$int
$$$$$$$(
$$$$$$$fmt
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        except ValueError
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return linestyle
$$$$$$$
$$$$$$$,
$$$$$$$ marker
$$$$$$$,
$$$$$$$ color  # Yes
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if fmt != fmtint
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                # user definitely doesn't want tri_down marker
                return linestyle
$$$$$$$
$$$$$$$,
$$$$$$$ marker
$$$$$$$,
$$$$$$$ color  # Yes
$$$$$$$
            else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                # ignore converted color
                color = None
$$$$$$$
    except ValueError
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        pass  # No
$$$$$$$
$$$$$$$,
$$$$$$$ not just a color.

$$$$$$$
    i = 0
    while i < len
$$$$$$$
$$$$$$$(
$$$$$$$fmt
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        c = fmt[i]
        if fmt[i
$$$$$$$
$$$$$$$:
$$$$$$$i+2] in mlines.lineStyles
$$$$$$$:
$$$$$$$  # First
$$$$$$$,
$$$$$$$ the two-char styles.
$$$$$$$
            if linestyle is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                    'Illegal format string "%s"; two linestyle symbols' % fmt
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            linestyle = fmt[i
$$$$$$$
$$$$$$$:
$$$$$$$i+2]
$$$$$$$
            i += 2
$$$$$$$
        elif c in mlines.lineStyles
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if linestyle is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                    'Illegal format string "%s"; two linestyle symbols' % fmt
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            linestyle = c
            i += 1
$$$$$$$
        elif c in mlines.lineMarkers
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if marker is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                    'Illegal format string "%s"; two marker symbols' % fmt
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            marker = c
            i += 1
$$$$$$$
        elif c in mcolors.get_named_colors_mapping
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if color is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                    'Illegal format string "%s"; two color symbols' % fmt
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            color = c
            i += 1
$$$$$$$
        elif c == 'C' and i < len
$$$$$$$
$$$$$$$(
$$$$$$$fmt
$$$$$$$)
$$$$$$$ - 1
$$$$$$$:
$$$$$$$
$$$$$$$
            color_cycle_number = int
$$$$$$$
$$$$$$$(
$$$$$$$fmt[i + 1]
$$$$$$$)
$$$$$$$
$$$$$$$
            color = mcolors.to_rgba
$$$$$$$
$$$$$$$(
$$$$$$$"C{}".format
$$$$$$$(
$$$$$$$color_cycle_number
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            i += 2
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                'Unrecognized character %c in format string' % c
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    if linestyle is None and marker is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        linestyle = mpl.rcParams['lines.linestyle']
$$$$$$$
    if linestyle is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        linestyle = 'None'
$$$$$$$
    if marker is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        marker = 'None'
$$$$$$$

$$$$$$$
    return linestyle
$$$$$$$
$$$$$$$,
$$$$$$$ marker
$$$$$$$,
$$$$$$$ color


class _process_plot_var_args
$$$$$$$:
$$$$$$$
$$$$$$$
    """
    Process variable length arguments to `~.Axes.plot`
$$$$$$$
$$$$$$$,
$$$$$$$ to support 
$$$$$$$:
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
      plot
$$$$$$$
$$$$$$$(
$$$$$$$t
$$$$$$$,
$$$$$$$ s
$$$$$$$)
$$$$$$$
$$$$$$$
      plot
$$$$$$$
$$$$$$$(
$$$$$$$t1
$$$$$$$,
$$$$$$$ s1
$$$$$$$,
$$$$$$$ t2
$$$$$$$,
$$$$$$$ s2
$$$$$$$)
$$$$$$$
$$$$$$$
      plot
$$$$$$$
$$$$$$$(
$$$$$$$t1
$$$$$$$,
$$$$$$$ s1
$$$$$$$,
$$$$$$$ 'ko'
$$$$$$$,
$$$$$$$ t2
$$$$$$$,
$$$$$$$ s2
$$$$$$$)
$$$$$$$
$$$$$$$
      plot
$$$$$$$
$$$$$$$(
$$$$$$$t1
$$$$$$$,
$$$$$$$ s1
$$$$$$$,
$$$$$$$ 'ko'
$$$$$$$,
$$$$$$$ t2
$$$$$$$,
$$$$$$$ s2
$$$$$$$,
$$$$$$$ 'r--'
$$$$$$$,
$$$$$$$ t3
$$$$$$$,
$$$$$$$ e3
$$$$$$$)
$$$$$$$

$$$$$$$
    an arbitrary number of *x*
$$$$$$$
$$$$$$$,
$$$$$$$ *y*
$$$$$$$,
$$$$$$$ *fmt* are allowed
$$$$$$$
    """
    def __init__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ axes
$$$$$$$,
$$$$$$$ command='plot'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        self.axes = axes
        self.command = command
        self.set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def __getstate__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # note
$$$$$$$
$$$$$$$:
$$$$$$$ it is not possible to pickle a generator 
$$$$$$$(
$$$$$$$and thus a cycler
$$$$$$$)
$$$$$$$.
$$$$$$$
        return {'axes'
$$$$$$$
$$$$$$$:
$$$$$$$ self.axes
$$$$$$$,
$$$$$$$ 'command'
$$$$$$$:
$$$$$$$ self.command}

$$$$$$$
    def __setstate__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ state
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        self.__dict__ = state.copy
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ *args
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # Can't do `args == 
$$$$$$$
$$$$$$$(
$$$$$$$None
$$$$$$$,
$$$$$$$
$$$$$$$)
$$$$$$$` as that crashes cycler.
$$$$$$$
        if not 
$$$$$$$
$$$$$$$(
$$$$$$$args or kwargs
$$$$$$$)
$$$$$$$ or 
$$$$$$$(
$$$$$$$len
$$$$$$$(
$$$$$$$args
$$$$$$$)
$$$$$$$ == 1 and args[0] is None
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            prop_cycler = mpl.rcParams['axes.prop_cycle']
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            prop_cycler = cycler
$$$$$$$
$$$$$$$(
$$$$$$$*args
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$

$$$$$$$
        self.prop_cycler = itertools.cycle
$$$$$$$
$$$$$$$(
$$$$$$$prop_cycler
$$$$$$$)
$$$$$$$
$$$$$$$
        # This should make a copy
        self._prop_keys = prop_cycler.keys
$$$$$$$

$$$$$$$
    def __call__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ *args
$$$$$$$,
$$$$$$$ data=None
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        self.axes._process_unit_info
$$$$$$$
$$$$$$$(
$$$$$$$kwargs=kwargs
$$$$$$$)
$$$$$$$

$$$$$$$
        for pos_only in "xy"
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if pos_only in kwargs
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise TypeError
$$$$$$$
$$$$$$$(
$$$$$$$"{} got an unexpected keyword argument {!r}"
$$$$$$$
                                .format
$$$$$$$
$$$$$$$(
$$$$$$$self.command
$$$$$$$,
$$$$$$$ pos_only
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        if not args
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return
$$$$$$$

$$$$$$$
        if data is None
$$$$$$$
$$$$$$$:
$$$$$$$  # Process dict views
$$$$$$$
            args = [cbook.sanitize_sequence
$$$$$$$
$$$$$$$(
$$$$$$$a
$$$$$$$)
$$$$$$$ for a in args]
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$  # Process the 'data' kwarg.
$$$$$$$
            replaced = [mpl._replacer
$$$$$$$
$$$$$$$(
$$$$$$$data
$$$$$$$,
$$$$$$$ arg
$$$$$$$)
$$$$$$$ for arg in args]
$$$$$$$
            if len
$$$$$$$
$$$$$$$(
$$$$$$$args
$$$$$$$)
$$$$$$$ == 1
$$$$$$$:
$$$$$$$
$$$$$$$
                label_namer_idx = 0
$$$$$$$
            elif len
$$$$$$$
$$$$$$$(
$$$$$$$args
$$$$$$$)
$$$$$$$ == 2
$$$$$$$:
$$$$$$$  # Can be x
$$$$$$$,
$$$$$$$ y or y
$$$$$$$,
$$$$$$$ c.
$$$$$$$
                # Figure out what the second argument is.
                # 1
$$$$$$$
$$$$$$$)
$$$$$$$ If the second argument cannot be a format shorthand
$$$$$$$,
$$$$$$$ the
$$$$$$$
                #    second argument is the label_namer.
                # 2
$$$$$$$
$$$$$$$)
$$$$$$$ Otherwise 
$$$$$$$(
$$$$$$$it could have been a format shorthand
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                #    a
$$$$$$$
$$$$$$$)
$$$$$$$ if we did perform a substitution
$$$$$$$,
$$$$$$$ emit a warning
$$$$$$$,
$$$$$$$ and
$$$$$$$
                #       use it as label_namer.
                #    b
$$$$$$$
$$$$$$$)
$$$$$$$ otherwise
$$$$$$$,
$$$$$$$ it is indeed a format shorthand; use the
$$$$$$$
                #       first argument as label_namer.
                try
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                    _process_plot_format
$$$$$$$
$$$$$$$(
$$$$$$$args[1]
$$$$$$$)
$$$$$$$
$$$$$$$
                except ValueError
$$$$$$$
$$$$$$$:
$$$$$$$  # case 1
$$$$$$$)
$$$$$$$
$$$$$$$
                    label_namer_idx = 1
$$$$$$$
                else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                    if replaced[1] is not args[1]
$$$$$$$
$$$$$$$:
$$$$$$$  # case 2a
$$$$$$$)
$$$$$$$
$$$$$$$
                        cbook._warn_external
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                            f"Second argument {args[1]!r} is ambiguous
$$$$$$$
$$$$$$$:
$$$$$$$ could "
$$$$$$$
                            f"be a format string but is in 'data'; using as "
                            f"data.  If it was intended as data
$$$$$$$
$$$$$$$,
$$$$$$$ set the "
$$$$$$$
                            f"format string to an empty string to suppress "
                            f"this warning.  If it was intended as a format "
                            f"string
$$$$$$$
$$$$$$$,
$$$$$$$ explicitly pass the x-values as well.  "
$$$$$$$
                            f"Alternatively
$$$$$$$
$$$$$$$,
$$$$$$$ rename the entry in 'data'."
$$$$$$$,
$$$$$$$
$$$$$$$
                            RuntimeWarning
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
                        label_namer_idx = 1
$$$$$$$
                    else
$$$$$$$
$$$$$$$:
$$$$$$$  # case 2b
$$$$$$$)
$$$$$$$
$$$$$$$
                        label_namer_idx = 0
$$$$$$$
            elif len
$$$$$$$
$$$$$$$(
$$$$$$$args
$$$$$$$)
$$$$$$$ == 3
$$$$$$$:
$$$$$$$
$$$$$$$
                label_namer_idx = 1
$$$$$$$
            else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                    "Using arbitrary long args with data is not supported due "
                    "to ambiguity of arguments; use multiple plotting calls "
                    "instead"
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            if kwargs.get
$$$$$$$
$$$$$$$(
$$$$$$$"label"
$$$$$$$)
$$$$$$$ is None
$$$$$$$:
$$$$$$$
$$$$$$$
                kwargs["label"] = mpl._label_from_arg
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                    replaced[label_namer_idx]
$$$$$$$
$$$$$$$,
$$$$$$$ args[label_namer_idx]
$$$$$$$)
$$$$$$$
$$$$$$$
            args = replaced
$$$$$$$

$$$$$$$
        # Repeatedly grab 
$$$$$$$
$$$$$$$(
$$$$$$$x
$$$$$$$,
$$$$$$$ y
$$$$$$$)
$$$$$$$ or 
$$$$$$$(
$$$$$$$x
$$$$$$$,
$$$$$$$ y
$$$$$$$,
$$$$$$$ format
$$$$$$$)
$$$$$$$ from the front of args and
$$$$$$$
        # massage them into arguments to plot
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$ or fill
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.

$$$$$$$
        while args
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            this
$$$$$$$
$$$$$$$,
$$$$$$$ args = args[
$$$$$$$:
$$$$$$$2]
$$$$$$$,
$$$$$$$ args[2
$$$$$$$:
$$$$$$$]
$$$$$$$
            if args and isinstance
$$$$$$$
$$$$$$$(
$$$$$$$args[0]
$$$$$$$,
$$$$$$$ str
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                this += args[0]
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                args = args[1
$$$$$$$
$$$$$$$:
$$$$$$$]
$$$$$$$
            yield from self._plot_args
$$$$$$$
$$$$$$$(
$$$$$$$this
$$$$$$$,
$$$$$$$ kwargs
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_next_color
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """Return the next color in the cycle."""
        if 'color' not in self._prop_keys
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return 'k'
$$$$$$$
        return next
$$$$$$$
$$$$$$$(
$$$$$$$self.prop_cycler
$$$$$$$)
$$$$$$$['color']

$$$$$$$
    def _getdefaults
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ ignore
$$$$$$$,
$$$$$$$ kw
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        If some keys in the property cycle 
$$$$$$$
$$$$$$$(
$$$$$$$excluding those in the set
$$$$$$$
        *ignore*
$$$$$$$
$$$$$$$)
$$$$$$$ are absent or set to None in the dict *kw*
$$$$$$$,
$$$$$$$ return a copy
$$$$$$$
        of the next entry in the property cycle
$$$$$$$
$$$$$$$,
$$$$$$$ excluding keys in *ignore*.
$$$$$$$
        Otherwise
$$$$$$$
$$$$$$$,
$$$$$$$ don't advance the property cycle
$$$$$$$,
$$$$$$$ and return an empty dict.
$$$$$$$
        """
        prop_keys = self._prop_keys - ignore
        if any
$$$$$$$
$$$$$$$(
$$$$$$$kw.get
$$$$$$$(
$$$$$$$k
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$ is None for k in prop_keys
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            # Need to copy this dictionary or else the next time around
            # in the cycle
$$$$$$$
$$$$$$$,
$$$$$$$ the dictionary could be missing entries.
$$$$$$$
            default_dict = next
$$$$$$$
$$$$$$$(
$$$$$$$self.prop_cycler
$$$$$$$)
$$$$$$$.copy
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            for p in ignore
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                default_dict.pop
$$$$$$$
$$$$$$$(
$$$$$$$p
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            default_dict = {}
$$$$$$$
        return default_dict
$$$$$$$

$$$$$$$
    def _setdefaults
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ defaults
$$$$$$$,
$$$$$$$ kw
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Add to the dict *kw* the entries in the dict *default* that are absent
        or set to None in *kw*.
        """
        for k in defaults
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if kw.get
$$$$$$$
$$$$$$$(
$$$$$$$k
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$ is None
$$$$$$$:
$$$$$$$
$$$$$$$
                kw[k] = defaults[k]
$$$$$$$

$$$$$$$
    def _makeline
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ x
$$$$$$$,
$$$$$$$ y
$$$$$$$,
$$$$$$$ kw
$$$$$$$,
$$$$$$$ kwargs
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        kw = {**kw
$$$$$$$
$$$$$$$,
$$$$$$$ **kwargs}  # Don't modify the original kw.
$$$$$$$
        default_dict = self._getdefaults
$$$$$$$
$$$$$$$(
$$$$$$$set
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ kw
$$$$$$$)
$$$$$$$
$$$$$$$
        self._setdefaults
$$$$$$$
$$$$$$$(
$$$$$$$default_dict
$$$$$$$,
$$$$$$$ kw
$$$$$$$)
$$$$$$$
$$$$$$$
        seg = mlines.Line2D
$$$$$$$
$$$$$$$(
$$$$$$$x
$$$$$$$,
$$$$$$$ y
$$$$$$$,
$$$$$$$ **kw
$$$$$$$)
$$$$$$$
$$$$$$$
        return seg
$$$$$$$
$$$$$$$,
$$$$$$$ kw

$$$$$$$
    def _makefill
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ x
$$$$$$$,
$$$$$$$ y
$$$$$$$,
$$$$$$$ kw
$$$$$$$,
$$$$$$$ kwargs
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # Polygon doesn't directly support unitized inputs.
        x = self.axes.convert_xunits
$$$$$$$
$$$$$$$(
$$$$$$$x
$$$$$$$)
$$$$$$$
$$$$$$$
        y = self.axes.convert_yunits
$$$$$$$
$$$$$$$(
$$$$$$$y
$$$$$$$)
$$$$$$$

$$$$$$$
        kw = kw.copy
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$  # Don't modify the original kw.
$$$$$$$
        kwargs = kwargs.copy
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        # Ignore 'marker'-related properties as they aren't Polygon
        # properties
$$$$$$$
$$$$$$$,
$$$$$$$ but they are Line2D properties
$$$$$$$,
$$$$$$$ and so they are
$$$$$$$
        # likely to appear in the default cycler construction.
        # This is done here to the defaults dictionary as opposed to the
        # other two dictionaries because we do want to capture when a
        # *user* explicitly specifies a marker which should be an error.
        # We also want to prevent advancing the cycler if there are no
        # defaults needed after ignoring the given properties.
        ignores = {'marker'
$$$$$$$
$$$$$$$,
$$$$$$$ 'markersize'
$$$$$$$,
$$$$$$$ 'markeredgecolor'
$$$$$$$,
$$$$$$$
$$$$$$$
                   'markerfacecolor'
$$$$$$$
$$$$$$$,
$$$$$$$ 'markeredgewidth'}
$$$$$$$
        # Also ignore anything provided by *kwargs*.
        for k
$$$$$$$
$$$$$$$,
$$$$$$$ v in kwargs.items
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if v is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                ignores.add
$$$$$$$
$$$$$$$(
$$$$$$$k
$$$$$$$)
$$$$$$$

$$$$$$$
        # Only using the first dictionary to use as basis
        # for getting defaults for back-compat reasons.
        # Doing it with both seems to mess things up in
        # various places 
$$$$$$$
$$$$$$$(
$$$$$$$probably due to logic bugs elsewhere
$$$$$$$)
$$$$$$$.
$$$$$$$
        default_dict = self._getdefaults
$$$$$$$
$$$$$$$(
$$$$$$$ignores
$$$$$$$,
$$$$$$$ kw
$$$$$$$)
$$$$$$$
$$$$$$$
        self._setdefaults
$$$$$$$
$$$$$$$(
$$$$$$$default_dict
$$$$$$$,
$$$$$$$ kw
$$$$$$$)
$$$$$$$

$$$$$$$
        # Looks like we don't want "color" to be interpreted to
        # mean both facecolor and edgecolor for some reason.
        # So the "kw" dictionary is thrown out
$$$$$$$
$$$$$$$,
$$$$$$$ and only its
$$$$$$$
        # 'color' value is kept and translated as a 'facecolor'.
        # This design should probably be revisited as it increases
        # complexity.
        facecolor = kw.get
$$$$$$$
$$$$$$$(
$$$$$$$'color'
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$

$$$$$$$
        # Throw out 'color' as it is now handled as a facecolor
        default_dict.pop
$$$$$$$
$$$$$$$(
$$$$$$$'color'
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$

$$$$$$$
        # To get other properties set from the cycler
        # modify the kwargs dictionary.
        self._setdefaults
$$$$$$$
$$$$$$$(
$$$$$$$default_dict
$$$$$$$,
$$$$$$$ kwargs
$$$$$$$)
$$$$$$$

$$$$$$$
        seg = mpatches.Polygon
$$$$$$$
$$$$$$$(
$$$$$$$np.column_stack
$$$$$$$(
$$$$$$$
$$$$$$$(
$$$$$$$x
$$$$$$$,
$$$$$$$ y
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                               facecolor=facecolor
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                               fill=kwargs.get
$$$$$$$
$$$$$$$(
$$$$$$$'fill'
$$$$$$$,
$$$$$$$ True
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                               closed=kw['closed']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        seg.set
$$$$$$$
$$$$$$$(
$$$$$$$**kwargs
$$$$$$$)
$$$$$$$
$$$$$$$
        return seg
$$$$$$$
$$$$$$$,
$$$$$$$ kwargs

$$$$$$$
    def _plot_args
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ tup
$$$$$$$,
$$$$$$$ kwargs
$$$$$$$,
$$$$$$$ return_kwargs=False
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        if len
$$$$$$$
$$$$$$$(
$$$$$$$tup
$$$$$$$)
$$$$$$$ > 1 and isinstance
$$$$$$$(
$$$$$$$tup[-1]
$$$$$$$,
$$$$$$$ str
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            linestyle
$$$$$$$
$$$$$$$,
$$$$$$$ marker
$$$$$$$,
$$$$$$$ color = _process_plot_format
$$$$$$$(
$$$$$$$tup[-1]
$$$$$$$)
$$$$$$$
$$$$$$$
            tup = tup[
$$$$$$$
$$$$$$$:
$$$$$$$-1]
$$$$$$$
        elif len
$$$$$$$
$$$$$$$(
$$$$$$$tup
$$$$$$$)
$$$$$$$ == 3
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$'third arg must be a format string'
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            linestyle
$$$$$$$
$$$$$$$,
$$$$$$$ marker
$$$$$$$,
$$$$$$$ color = None
$$$$$$$,
$$$$$$$ None
$$$$$$$,
$$$$$$$ None

$$$$$$$
        # Don't allow any None value; these would be up-converted to one
        # element array of None which causes problems downstream.
        if any
$$$$$$$
$$$$$$$(
$$$$$$$v is None for v in tup
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$"x
$$$$$$$,
$$$$$$$ y
$$$$$$$,
$$$$$$$ and format string must not be None"
$$$$$$$)
$$$$$$$

$$$$$$$
        kw = {}
        for k
$$$$$$$
$$$$$$$,
$$$$$$$ v in zip
$$$$$$$(
$$$$$$$
$$$$$$$(
$$$$$$$'linestyle'
$$$$$$$,
$$$$$$$ 'marker'
$$$$$$$,
$$$$$$$ 'color'
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                        
$$$$$$$
$$$$$$$(
$$$$$$$linestyle
$$$$$$$,
$$$$$$$ marker
$$$$$$$,
$$$$$$$ color
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if v is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                kw[k] = v
$$$$$$$

$$$$$$$
        if len
$$$$$$$
$$$$$$$(
$$$$$$$tup
$$$$$$$)
$$$$$$$ == 2
$$$$$$$:
$$$$$$$
$$$$$$$
            x = _check_1d
$$$$$$$
$$$$$$$(
$$$$$$$tup[0]
$$$$$$$)
$$$$$$$
$$$$$$$
            y = _check_1d
$$$$$$$
$$$$$$$(
$$$$$$$tup[-1]
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            x
$$$$$$$
$$$$$$$,
$$$$$$$ y = index_of
$$$$$$$(
$$$$$$$tup[-1]
$$$$$$$)
$$$$$$$

$$$$$$$
        if self.axes.xaxis is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.axes.xaxis.update_units
$$$$$$$
$$$$$$$(
$$$$$$$x
$$$$$$$)
$$$$$$$
$$$$$$$
        if self.axes.yaxis is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.axes.yaxis.update_units
$$$$$$$
$$$$$$$(
$$$$$$$y
$$$$$$$)
$$$$$$$

$$$$$$$
        if x.shape[0] != y.shape[0]
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$f"x and y must have same first dimension
$$$$$$$,
$$$$$$$ but "
$$$$$$$
                             f"have shapes {x.shape} and {y.shape}"
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if x.ndim > 2 or y.ndim > 2
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$f"x and y can be no greater than 2D
$$$$$$$,
$$$$$$$ but have "
$$$$$$$
                             f"shapes {x.shape} and {y.shape}"
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if x.ndim == 1
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            x = x[
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$,
$$$$$$$ np.newaxis]
$$$$$$$
        if y.ndim == 1
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            y = y[
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$,
$$$$$$$ np.newaxis]

$$$$$$$
        if self.command == 'plot'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            func = self._makeline
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            kw['closed'] = kwargs.get
$$$$$$$
$$$$$$$(
$$$$$$$'closed'
$$$$$$$,
$$$$$$$ True
$$$$$$$)
$$$$$$$
$$$$$$$
            func = self._makefill
$$$$$$$

$$$$$$$
        ncx
$$$$$$$
$$$$$$$,
$$$$$$$ ncy = x.shape[1]
$$$$$$$,
$$$$$$$ y.shape[1]
$$$$$$$
        if ncx > 1 and ncy > 1 and ncx != ncy
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$f"x has {ncx} columns but y has {ncy} columns"
$$$$$$$)
$$$$$$$
$$$$$$$
        result = 
$$$$$$$
$$$$$$$(
$$$$$$$func
$$$$$$$(
$$$$$$$x[
$$$$$$$:
$$$$$$$
$$$$$$$,
$$$$$$$ j % ncx]
$$$$$$$,
$$$$$$$ y[
$$$$$$$:
$$$$$$$
$$$$$$$,
$$$$$$$ j % ncy]
$$$$$$$,
$$$$$$$ kw
$$$$$$$,
$$$$$$$ kwargs
$$$$$$$)
$$$$$$$
$$$$$$$
                  for j in range
$$$$$$$
$$$$$$$(
$$$$$$$max
$$$$$$$(
$$$$$$$ncx
$$$$$$$,
$$$$$$$ ncy
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if return_kwargs
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return list
$$$$$$$
$$$$$$$(
$$$$$$$result
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return [l[0] for l in result]
$$$$$$$


@cbook._define_aliases
$$$$$$$(
$$$$$$${"facecolor"
$$$$$$$:
$$$$$$$ ["fc"]}
$$$$$$$)
$$$$$$$
class _AxesBase
$$$$$$$(
$$$$$$$martist.Artist
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
    name = "rectilinear"
$$$$$$$

$$$$$$$
    _shared_x_axes = cbook.Grouper
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
    _shared_y_axes = cbook.Grouper
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
    _twinned_axes = cbook.Grouper
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def __str__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        return "{0}
$$$$$$$
$$$$$$$(
$$$$$$${1[0]
$$$$$$$:
$$$$$$$g}
$$$$$$$,
$$$$$$${1[1]
$$$$$$$:
$$$$$$$g};{1[2]
$$$$$$$:
$$$$$$$g}x{1[3]
$$$$$$$:
$$$$$$$g}
$$$$$$$)
$$$$$$$".format
$$$$$$$(
$$$$$$$
$$$$$$$
            type
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$.__name__
$$$$$$$,
$$$$$$$ self._position.bounds
$$$$$$$)
$$$$$$$

$$$$$$$
    @cbook._make_keyword_only
$$$$$$$
$$$$$$$(
$$$$$$$"3.4"
$$$$$$$,
$$$$$$$ "facecolor"
$$$$$$$)
$$$$$$$
$$$$$$$
    def __init__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ fig
$$$$$$$,
$$$$$$$ rect
$$$$$$$,
$$$$$$$
$$$$$$$
                 facecolor=None
$$$$$$$
$$$$$$$,
$$$$$$$  # defaults to rc axes.facecolor
$$$$$$$
                 frameon=True
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                 sharex=None
$$$$$$$
$$$$$$$,
$$$$$$$  # use Axes instance's xaxis info
$$$$$$$
                 sharey=None
$$$$$$$
$$$$$$$,
$$$$$$$  # use Axes instance's yaxis info
$$$$$$$
                 label=''
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                 xscale=None
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                 yscale=None
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                 box_aspect=None
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                 **kwargs
                 
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Build an axes in a figure.
$$$$$$$

$$$$$$$
        Parameters
        ----------
        fig 
$$$$$$$
$$$$$$$:
$$$$$$$ `~matplotlib.figure.Figure`
$$$$$$$
            The axes is build in the `.Figure` *fig*.
$$$$$$$

$$$$$$$
        rect 
$$$$$$$
$$$$$$$:
$$$$$$$ [left
$$$$$$$,
$$$$$$$ bottom
$$$$$$$,
$$$$$$$ width
$$$$$$$,
$$$$$$$ height]
$$$$$$$
            The axes is build in the rectangle *rect*. *rect* is in
            `.Figure` coordinates.
$$$$$$$

$$$$$$$
        sharex
$$$$$$$
$$$$$$$,
$$$$$$$ sharey 
$$$$$$$:
$$$$$$$ `~.axes.Axes`
$$$$$$$,
$$$$$$$ optional
$$$$$$$
            The x or y `~.matplotlib.axis` is shared with the x or
            y axis in the input `~.axes.Axes`.
$$$$$$$

$$$$$$$
        frameon 
$$$$$$$
$$$$$$$:
$$$$$$$ bool
$$$$$$$,
$$$$$$$ default
$$$$$$$:
$$$$$$$ True
$$$$$$$
            Whether the axes frame is visible.
$$$$$$$

$$$$$$$
        box_aspect 
$$$$$$$
$$$$$$$:
$$$$$$$ float
$$$$$$$,
$$$$$$$ optional
$$$$$$$
            Set a fixed aspect for the axes box
$$$$$$$
$$$$$$$,
$$$$$$$ i.e. the ratio of height to
$$$$$$$
            width. See `~.axes.Axes.set_box_aspect` for details.
$$$$$$$

$$$$$$$
        **kwargs
$$$$$$$
            Other optional keyword arguments
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
            %
$$$$$$$
$$$$$$$(
$$$$$$$Axes
$$$$$$$)
$$$$$$$s

$$$$$$$
        Returns
        -------
        `~.axes.Axes`
$$$$$$$
            The new `~.axes.Axes` object.
$$$$$$$
        """
$$$$$$$

$$$$$$$
        super
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.__init__
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if isinstance
$$$$$$$
$$$$$$$(
$$$$$$$rect
$$$$$$$,
$$$$$$$ mtransforms.Bbox
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._position = rect
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._position = mtransforms.Bbox.from_bounds
$$$$$$$
$$$$$$$(
$$$$$$$*rect
$$$$$$$)
$$$$$$$
$$$$$$$
        if self._position.width < 0 or self._position.height < 0
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$'Width and height specified must be non-negative'
$$$$$$$)
$$$$$$$
$$$$$$$
        self._originalPosition = self._position.frozen
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.axes = self
        self._aspect = 'auto'
        self._adjustable = 'box'
        self._anchor = 'C'
        self._stale_viewlim_x = False
        self._stale_viewlim_y = False
        self._sharex = sharex
        self._sharey = sharey
        self.set_label
$$$$$$$
$$$$$$$(
$$$$$$$label
$$$$$$$)
$$$$$$$
$$$$$$$
        self.set_figure
$$$$$$$
$$$$$$$(
$$$$$$$fig
$$$$$$$)
$$$$$$$
$$$$$$$
        self.set_box_aspect
$$$$$$$
$$$$$$$(
$$$$$$$box_aspect
$$$$$$$)
$$$$$$$
$$$$$$$
        self._axes_locator = None  # Optionally set via update
$$$$$$$
$$$$$$$(
$$$$$$$kwargs
$$$$$$$)
$$$$$$$.
$$$$$$$
        # placeholder for any colorbars added that use this axes.
        # 
$$$$$$$
$$$$$$$(
$$$$$$$see colorbar.py
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        self._colorbars = []
        self.spines = self._gen_axes_spines
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        # this call may differ for non-sep axes
$$$$$$$
$$$$$$$,
$$$$$$$ e.g.
$$$$$$$,
$$$$$$$ polar
$$$$$$$
        self._init_axis
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if facecolor is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            facecolor = mpl.rcParams['axes.facecolor']
$$$$$$$
        self._facecolor = facecolor
        self._frameon = frameon
        self.set_axisbelow
$$$$$$$
$$$$$$$(
$$$$$$$mpl.rcParams['axes.axisbelow']
$$$$$$$)
$$$$$$$

$$$$$$$
        self._rasterization_zorder = None
        self.cla
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        # funcs used to format x and y - fall back on major formatters
        self.fmt_xdata = None
        self.fmt_ydata = None
$$$$$$$

$$$$$$$
        self.set_navigate
$$$$$$$
$$$$$$$(
$$$$$$$True
$$$$$$$)
$$$$$$$
$$$$$$$
        self.set_navigate_mode
$$$$$$$
$$$$$$$(
$$$$$$$None
$$$$$$$)
$$$$$$$

$$$$$$$
        if xscale
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.set_xscale
$$$$$$$
$$$$$$$(
$$$$$$$xscale
$$$$$$$)
$$$$$$$
$$$$$$$
        if yscale
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.set_yscale
$$$$$$$
$$$$$$$(
$$$$$$$yscale
$$$$$$$)
$$$$$$$

$$$$$$$
        self.update
$$$$$$$
$$$$$$$(
$$$$$$$kwargs
$$$$$$$)
$$$$$$$

$$$$$$$
        if self.xaxis is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._xcid = self.xaxis.callbacks.connect
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                'units finalize'
$$$$$$$
$$$$$$$,
$$$$$$$ lambda
$$$$$$$:
$$$$$$$ self._on_units_changed
$$$$$$$(
$$$$$$$scalex=True
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        if self.yaxis is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._ycid = self.yaxis.callbacks.connect
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                'units finalize'
$$$$$$$
$$$$$$$,
$$$$$$$ lambda
$$$$$$$:
$$$$$$$ self._on_units_changed
$$$$$$$(
$$$$$$$scaley=True
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        rcParams = mpl.rcParams
        self.tick_params
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            top=rcParams['xtick.top'] and rcParams['xtick.minor.top']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            labeltop=
$$$$$$$
$$$$$$$(
$$$$$$$rcParams['xtick.labeltop'] and
$$$$$$$
                      rcParams['xtick.minor.top']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            labelbottom=
$$$$$$$
$$$$$$$(
$$$$$$$rcParams['xtick.labelbottom'] and
$$$$$$$
                         rcParams['xtick.minor.bottom']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            left=rcParams['ytick.left'] and rcParams['ytick.minor.left']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            right=rcParams['ytick.right'] and rcParams['ytick.minor.right']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            labelleft=
$$$$$$$
$$$$$$$(
$$$$$$$rcParams['ytick.labelleft'] and
$$$$$$$
                       rcParams['ytick.minor.left']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            labelright=
$$$$$$$
$$$$$$$(
$$$$$$$rcParams['ytick.labelright'] and
$$$$$$$
                        rcParams['ytick.minor.right']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            which='minor'
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        self.tick_params
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            top=rcParams['xtick.top'] and rcParams['xtick.major.top']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            labeltop=
$$$$$$$
$$$$$$$(
$$$$$$$rcParams['xtick.labeltop'] and
$$$$$$$
                      rcParams['xtick.major.top']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            labelbottom=
$$$$$$$
$$$$$$$(
$$$$$$$rcParams['xtick.labelbottom'] and
$$$$$$$
                         rcParams['xtick.major.bottom']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            left=rcParams['ytick.left'] and rcParams['ytick.major.left']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            right=rcParams['ytick.right'] and rcParams['ytick.major.right']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            labelleft=
$$$$$$$
$$$$$$$(
$$$$$$$rcParams['ytick.labelleft'] and
$$$$$$$
                       rcParams['ytick.major.left']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            labelright=
$$$$$$$
$$$$$$$(
$$$$$$$rcParams['ytick.labelright'] and
$$$$$$$
                        rcParams['ytick.major.right']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            which='major'
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def __getstate__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # The renderer should be re-created by the figure
$$$$$$$
$$$$$$$,
$$$$$$$ and then cached at
$$$$$$$
        # that point.
        state = super
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.__getstate__
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        # Prune the sharing & twinning info to only contain the current group.
        for grouper_name in [
$$$$$$$
                '_shared_x_axes'
$$$$$$$
$$$$$$$,
$$$$$$$ '_shared_y_axes'
$$$$$$$,
$$$$$$$ '_twinned_axes']
$$$$$$$:
$$$$$$$
$$$$$$$
            grouper = getattr
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ grouper_name
$$$$$$$)
$$$$$$$
$$$$$$$
            state[grouper_name] = 
$$$$$$$
$$$$$$$(
$$$$$$$grouper.get_siblings
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$
                                   if self in grouper else None
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        return state
$$$$$$$

$$$$$$$
    def __setstate__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ state
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # Merge the grouping info back into the global groupers.
        for grouper_name in [
$$$$$$$
                '_shared_x_axes'
$$$$$$$
$$$$$$$,
$$$$$$$ '_shared_y_axes'
$$$$$$$,
$$$$$$$ '_twinned_axes']
$$$$$$$:
$$$$$$$
$$$$$$$
            siblings = state.pop
$$$$$$$
$$$$$$$(
$$$$$$$grouper_name
$$$$$$$)
$$$$$$$
$$$$$$$
            if siblings
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                getattr
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ grouper_name
$$$$$$$)
$$$$$$$.join
$$$$$$$(
$$$$$$$*siblings
$$$$$$$)
$$$$$$$
$$$$$$$
        self.__dict__ = state
        self._stale = True
$$$$$$$

$$$$$$$
    def __repr__
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        fields = []
        if self.get_label
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            fields += [f"label={self.get_label
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$!r}"]
$$$$$$$
        titles = []
        for k in ["left"
$$$$$$$
$$$$$$$,
$$$$$$$ "center"
$$$$$$$,
$$$$$$$ "right"]
$$$$$$$:
$$$$$$$
$$$$$$$
            title = self.get_title
$$$$$$$
$$$$$$$(
$$$$$$$loc=k
$$$$$$$)
$$$$$$$
$$$$$$$
            if title
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                titles.append
$$$$$$$
$$$$$$$(
$$$$$$$f"{k!r}
$$$$$$$:
$$$$$$${title!r}"
$$$$$$$)
$$$$$$$
$$$$$$$
        if titles
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            fields += ["title={" + "
$$$$$$$
$$$$$$$,
$$$$$$$".join
$$$$$$$(
$$$$$$$titles
$$$$$$$)
$$$$$$$ + "}"]
$$$$$$$
        if self.get_xlabel
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            fields += [f"xlabel={self.get_xlabel
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$!r}"]
$$$$$$$
        if self.get_ylabel
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            fields += [f"ylabel={self.get_ylabel
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$!r}"]
$$$$$$$
        return f"<{self.__class__.__name__}
$$$$$$$
$$$$$$$:
$$$$$$$" + "
$$$$$$$,
$$$$$$$ ".join
$$$$$$$(
$$$$$$$fields
$$$$$$$)
$$$$$$$ + ">"

$$$$$$$
    def get_window_extent
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ *args
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return the axes bounding box in display space; *args* and *kwargs*
        are empty.
$$$$$$$

$$$$$$$
        This bounding box does not include the spines
$$$$$$$
$$$$$$$,
$$$$$$$ ticks
$$$$$$$,
$$$$$$$ ticklables
$$$$$$$,
$$$$$$$
$$$$$$$
        or other labels.  For a bounding box including these elements use
        `~matplotlib.axes.Axes.get_tightbbox`.
$$$$$$$

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.get_tightbbox
        matplotlib.axis.Axis.get_tightbbox
        matplotlib.spines.Spine.get_window_extent
        """
        return self.bbox
$$$$$$$

$$$$$$$
    def _init_axis
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # This is moved out of __init__ because non-separable axes don't use it
        self.xaxis = maxis.XAxis
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$
        self.spines['bottom'].register_axis
$$$$$$$
$$$$$$$(
$$$$$$$self.xaxis
$$$$$$$)
$$$$$$$
$$$$$$$
        self.spines['top'].register_axis
$$$$$$$
$$$$$$$(
$$$$$$$self.xaxis
$$$$$$$)
$$$$$$$
$$$$$$$
        self.yaxis = maxis.YAxis
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$
        self.spines['left'].register_axis
$$$$$$$
$$$$$$$(
$$$$$$$self.yaxis
$$$$$$$)
$$$$$$$
$$$$$$$
        self.spines['right'].register_axis
$$$$$$$
$$$$$$$(
$$$$$$$self.yaxis
$$$$$$$)
$$$$$$$
$$$$$$$
        self._update_transScale
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def set_figure
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ fig
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # docstring inherited
        super
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.set_figure
$$$$$$$(
$$$$$$$fig
$$$$$$$)
$$$$$$$

$$$$$$$
        self.bbox = mtransforms.TransformedBbox
$$$$$$$
$$$$$$$(
$$$$$$$self._position
$$$$$$$,
$$$$$$$
$$$$$$$
                                                fig.transSubfigure
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        # these will be updated later as data is added
        self.dataLim = mtransforms.Bbox.null
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self._viewLim = mtransforms.Bbox.unit
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.transScale = mtransforms.TransformWrapper
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            mtransforms.IdentityTransform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        self._set_lim_and_transforms
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def _unstale_viewLim
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        # We should arrange to store this information once per share-group
        # instead of on every axis.
        scalex = any
$$$$$$$
$$$$$$$(
$$$$$$$ax._stale_viewlim_x
$$$$$$$
                     for ax in self._shared_x_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        scaley = any
$$$$$$$
$$$$$$$(
$$$$$$$ax._stale_viewlim_y
$$$$$$$
                     for ax in self._shared_y_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if scalex or scaley
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            for ax in self._shared_x_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                ax._stale_viewlim_x = False
$$$$$$$
            for ax in self._shared_y_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                ax._stale_viewlim_y = False
$$$$$$$
            self.autoscale_view
$$$$$$$
$$$$$$$(
$$$$$$$scalex=scalex
$$$$$$$,
$$$$$$$ scaley=scaley
$$$$$$$)
$$$$$$$

$$$$$$$
    @property
    def viewLim
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        self._unstale_viewLim
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        return self._viewLim
$$$$$$$

$$$$$$$
    # API could be better
$$$$$$$
$$$$$$$,
$$$$$$$ right now this is just to match the old calls to
$$$$$$$
    # autoscale_view
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$ after each plotting method.
$$$$$$$
    def _request_autoscale_view
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ tight=None
$$$$$$$,
$$$$$$$ scalex=True
$$$$$$$,
$$$$$$$ scaley=True
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        if tight is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._tight = tight
$$$$$$$
        if scalex
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._stale_viewlim_x = True  # Else keep old state.
$$$$$$$
        if scaley
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._stale_viewlim_y = True
$$$$$$$

$$$$$$$
    def _set_lim_and_transforms
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the *_xaxis_transform*
$$$$$$$
$$$$$$$,
$$$$$$$ *_yaxis_transform*
$$$$$$$,
$$$$$$$ *transScale*
$$$$$$$,
$$$$$$$
$$$$$$$
        *transData*
$$$$$$$
$$$$$$$,
$$$$$$$ *transLimits* and *transAxes* transformations.

$$$$$$$
        .. note
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
            This method is primarily used by rectilinear projections of the
            `~matplotlib.axes.Axes` class
$$$$$$$
$$$$$$$,
$$$$$$$ and is meant to be overridden by
$$$$$$$
            new kinds of projection axes that need different transformations
            and limits. 
$$$$$$$
$$$$$$$(
$$$$$$$See `~matplotlib.projections.polar.PolarAxes` for an
$$$$$$$
            example.
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        """
        self.transAxes = mtransforms.BboxTransformTo
$$$$$$$
$$$$$$$(
$$$$$$$self.bbox
$$$$$$$)
$$$$$$$

$$$$$$$
        # Transforms the x and y axis separately by a scale factor.
        # It is assumed that this part will have non-linear components
        # 
$$$$$$$
$$$$$$$(
$$$$$$$e.g.
$$$$$$$,
$$$$$$$ for a log scale
$$$$$$$)
$$$$$$$.
$$$$$$$
        self.transScale = mtransforms.TransformWrapper
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            mtransforms.IdentityTransform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        # An affine transformation on the data
$$$$$$$
$$$$$$$,
$$$$$$$ generally to limit the
$$$$$$$
        # range of the axes
        self.transLimits = mtransforms.BboxTransformFrom
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            mtransforms.TransformedBbox
$$$$$$$
$$$$$$$(
$$$$$$$self._viewLim
$$$$$$$,
$$$$$$$ self.transScale
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        # The parentheses are important for efficiency here -- they
        # group the last two 
$$$$$$$
$$$$$$$(
$$$$$$$which are usually affines
$$$$$$$)
$$$$$$$ separately
$$$$$$$
        # from the first 
$$$$$$$
$$$$$$$(
$$$$$$$which
$$$$$$$,
$$$$$$$ with log-scaling can be non-affine
$$$$$$$)
$$$$$$$.
$$$$$$$
        self.transData = self.transScale + 
$$$$$$$
$$$$$$$(
$$$$$$$self.transLimits + self.transAxes
$$$$$$$)
$$$$$$$

$$$$$$$
        self._xaxis_transform = mtransforms.blended_transform_factory
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            self.transData
$$$$$$$
$$$$$$$,
$$$$$$$ self.transAxes
$$$$$$$)
$$$$$$$
$$$$$$$
        self._yaxis_transform = mtransforms.blended_transform_factory
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            self.transAxes
$$$$$$$
$$$$$$$,
$$$$$$$ self.transData
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_xaxis_transform
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ which='grid'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Get the transformation used for drawing x-axis labels
$$$$$$$
$$$$$$$,
$$$$$$$ ticks
$$$$$$$
        and gridlines.  The x-direction is in data coordinates and the
        y-direction is in axis coordinates.
$$$$$$$

$$$$$$$
        .. note
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
            This transformation is primarily used by the
            `~matplotlib.axis.Axis` class
$$$$$$$
$$$$$$$,
$$$$$$$ and is meant to be
$$$$$$$
            overridden by new kinds of projections that may need to
            place axis elements in different locations.
$$$$$$$
        """
        if which == 'grid'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return self._xaxis_transform
$$$$$$$
        elif which == 'tick1'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            # for cartesian projection
$$$$$$$
$$$$$$$,
$$$$$$$ this is bottom spine
$$$$$$$
            return self.spines['bottom'].get_spine_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        elif which == 'tick2'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            # for cartesian projection
$$$$$$$
$$$$$$$,
$$$$$$$ this is top spine
$$$$$$$
            return self.spines['top'].get_spine_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$'unknown value for which'
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_xaxis_text1_transform
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ pad_points
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Returns
        -------
        transform 
$$$$$$$
$$$$$$$:
$$$$$$$ Transform
$$$$$$$
            The transform used for drawing x-axis labels
$$$$$$$
$$$$$$$,
$$$$$$$ which will add
$$$$$$$
            *pad_points* of padding 
$$$$$$$
$$$$$$$(
$$$$$$$in points
$$$$$$$)
$$$$$$$ between the axes and the label.
$$$$$$$
            The x-direction is in data coordinates and the y-direction is in
            axis corrdinates
$$$$$$$
        valign 
$$$$$$$
$$$$$$$:
$$$$$$$ {'center'
$$$$$$$,
$$$$$$$ 'top'
$$$$$$$,
$$$$$$$ 'bottom'
$$$$$$$,
$$$$$$$ 'baseline'
$$$$$$$,
$$$$$$$ 'center_baseline'}
$$$$$$$
            The text vertical alignment.
$$$$$$$
        halign 
$$$$$$$
$$$$$$$:
$$$$$$$ {'center'
$$$$$$$,
$$$$$$$ 'left'
$$$$$$$,
$$$$$$$ 'right'}
$$$$$$$
            The text horizontal alignment.
$$$$$$$

$$$$$$$
        Notes
        -----
        This transformation is primarily used by the `~matplotlib.axis.Axis`
        class
$$$$$$$
$$$$$$$,
$$$$$$$ and is meant to be overridden by new kinds of projections that
$$$$$$$
        may need to place axis elements in different locations.
        """
        labels_align = mpl.rcParams["xtick.alignment"]
        return 
$$$$$$$
$$$$$$$(
$$$$$$$self.get_xaxis_transform
$$$$$$$(
$$$$$$$which='tick1'
$$$$$$$)
$$$$$$$ +
$$$$$$$
                mtransforms.ScaledTranslation
$$$$$$$
$$$$$$$(
$$$$$$$0
$$$$$$$,
$$$$$$$ -1 * pad_points / 72
$$$$$$$,
$$$$$$$
$$$$$$$
                                              self.figure.dpi_scale_trans
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                "top"
$$$$$$$
$$$$$$$,
$$$$$$$ labels_align
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_xaxis_text2_transform
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ pad_points
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Returns
        -------
        transform 
$$$$$$$
$$$$$$$:
$$$$$$$ Transform
$$$$$$$
            The transform used for drawing secondary x-axis labels
$$$$$$$
$$$$$$$,
$$$$$$$ which will
$$$$$$$
            add *pad_points* of padding 
$$$$$$$
$$$$$$$(
$$$$$$$in points
$$$$$$$)
$$$$$$$ between the axes and the
$$$$$$$
            label.  The x-direction is in data coordinates and the y-direction
            is in axis corrdinates
$$$$$$$
        valign 
$$$$$$$
$$$$$$$:
$$$$$$$ {'center'
$$$$$$$,
$$$$$$$ 'top'
$$$$$$$,
$$$$$$$ 'bottom'
$$$$$$$,
$$$$$$$ 'baseline'
$$$$$$$,
$$$$$$$ 'center_baseline'}
$$$$$$$
            The text vertical alignment.
$$$$$$$
        halign 
$$$$$$$
$$$$$$$:
$$$$$$$ {'center'
$$$$$$$,
$$$$$$$ 'left'
$$$$$$$,
$$$$$$$ 'right'}
$$$$$$$
            The text horizontal alignment.
$$$$$$$

$$$$$$$
        Notes
        -----
        This transformation is primarily used by the `~matplotlib.axis.Axis`
        class
$$$$$$$
$$$$$$$,
$$$$$$$ and is meant to be overridden by new kinds of projections that
$$$$$$$
        may need to place axis elements in different locations.
        """
        labels_align = mpl.rcParams["xtick.alignment"]
        return 
$$$$$$$
$$$$$$$(
$$$$$$$self.get_xaxis_transform
$$$$$$$(
$$$$$$$which='tick2'
$$$$$$$)
$$$$$$$ +
$$$$$$$
                mtransforms.ScaledTranslation
$$$$$$$
$$$$$$$(
$$$$$$$0
$$$$$$$,
$$$$$$$ pad_points / 72
$$$$$$$,
$$$$$$$
$$$$$$$
                                              self.figure.dpi_scale_trans
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                "bottom"
$$$$$$$
$$$$$$$,
$$$$$$$ labels_align
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_yaxis_transform
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ which='grid'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Get the transformation used for drawing y-axis labels
$$$$$$$
$$$$$$$,
$$$$$$$ ticks
$$$$$$$
        and gridlines.  The x-direction is in axis coordinates and the
        y-direction is in data coordinates.
$$$$$$$

$$$$$$$
        .. note
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
            This transformation is primarily used by the
            `~matplotlib.axis.Axis` class
$$$$$$$
$$$$$$$,
$$$$$$$ and is meant to be
$$$$$$$
            overridden by new kinds of projections that may need to
            place axis elements in different locations.
$$$$$$$
        """
        if which == 'grid'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return self._yaxis_transform
$$$$$$$
        elif which == 'tick1'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            # for cartesian projection
$$$$$$$
$$$$$$$,
$$$$$$$ this is bottom spine
$$$$$$$
            return self.spines['left'].get_spine_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        elif which == 'tick2'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            # for cartesian projection
$$$$$$$
$$$$$$$,
$$$$$$$ this is top spine
$$$$$$$
            return self.spines['right'].get_spine_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$'unknown value for which'
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_yaxis_text1_transform
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ pad_points
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Returns
        -------
        transform 
$$$$$$$
$$$$$$$:
$$$$$$$ Transform
$$$$$$$
            The transform used for drawing y-axis labels
$$$$$$$
$$$$$$$,
$$$$$$$ which will add
$$$$$$$
            *pad_points* of padding 
$$$$$$$
$$$$$$$(
$$$$$$$in points
$$$$$$$)
$$$$$$$ between the axes and the label.
$$$$$$$
            The x-direction is in axis coordinates and the y-direction is in
            data corrdinates
$$$$$$$
        valign 
$$$$$$$
$$$$$$$:
$$$$$$$ {'center'
$$$$$$$,
$$$$$$$ 'top'
$$$$$$$,
$$$$$$$ 'bottom'
$$$$$$$,
$$$$$$$ 'baseline'
$$$$$$$,
$$$$$$$ 'center_baseline'}
$$$$$$$
            The text vertical alignment.
$$$$$$$
        halign 
$$$$$$$
$$$$$$$:
$$$$$$$ {'center'
$$$$$$$,
$$$$$$$ 'left'
$$$$$$$,
$$$$$$$ 'right'}
$$$$$$$
            The text horizontal alignment.
$$$$$$$

$$$$$$$
        Notes
        -----
        This transformation is primarily used by the `~matplotlib.axis.Axis`
        class
$$$$$$$
$$$$$$$,
$$$$$$$ and is meant to be overridden by new kinds of projections that
$$$$$$$
        may need to place axis elements in different locations.
        """
        labels_align = mpl.rcParams["ytick.alignment"]
        return 
$$$$$$$
$$$$$$$(
$$$$$$$self.get_yaxis_transform
$$$$$$$(
$$$$$$$which='tick1'
$$$$$$$)
$$$$$$$ +
$$$$$$$
                mtransforms.ScaledTranslation
$$$$$$$
$$$$$$$(
$$$$$$$-1 * pad_points / 72
$$$$$$$,
$$$$$$$ 0
$$$$$$$,
$$$$$$$
$$$$$$$
                                              self.figure.dpi_scale_trans
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                labels_align
$$$$$$$
$$$$$$$,
$$$$$$$ "right"
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_yaxis_text2_transform
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ pad_points
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Returns
        -------
        transform 
$$$$$$$
$$$$$$$:
$$$$$$$ Transform
$$$$$$$
            The transform used for drawing secondart y-axis labels
$$$$$$$
$$$$$$$,
$$$$$$$ which will
$$$$$$$
            add *pad_points* of padding 
$$$$$$$
$$$$$$$(
$$$$$$$in points
$$$$$$$)
$$$$$$$ between the axes and the
$$$$$$$
            label.  The x-direction is in axis coordinates and the y-direction
            is in data corrdinates
$$$$$$$
        valign 
$$$$$$$
$$$$$$$:
$$$$$$$ {'center'
$$$$$$$,
$$$$$$$ 'top'
$$$$$$$,
$$$$$$$ 'bottom'
$$$$$$$,
$$$$$$$ 'baseline'
$$$$$$$,
$$$$$$$ 'center_baseline'}
$$$$$$$
            The text vertical alignment.
$$$$$$$
        halign 
$$$$$$$
$$$$$$$:
$$$$$$$ {'center'
$$$$$$$,
$$$$$$$ 'left'
$$$$$$$,
$$$$$$$ 'right'}
$$$$$$$
            The text horizontal alignment.
$$$$$$$

$$$$$$$
        Notes
        -----
        This transformation is primarily used by the `~matplotlib.axis.Axis`
        class
$$$$$$$
$$$$$$$,
$$$$$$$ and is meant to be overridden by new kinds of projections that
$$$$$$$
        may need to place axis elements in different locations.
        """
        labels_align = mpl.rcParams["ytick.alignment"]
        return 
$$$$$$$
$$$$$$$(
$$$$$$$self.get_yaxis_transform
$$$$$$$(
$$$$$$$which='tick2'
$$$$$$$)
$$$$$$$ +
$$$$$$$
                mtransforms.ScaledTranslation
$$$$$$$
$$$$$$$(
$$$$$$$pad_points / 72
$$$$$$$,
$$$$$$$ 0
$$$$$$$,
$$$$$$$
$$$$$$$
                                              self.figure.dpi_scale_trans
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                labels_align
$$$$$$$
$$$$$$$,
$$$$$$$ "left"
$$$$$$$)
$$$$$$$

$$$$$$$
    def _update_transScale
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        self.transScale.set
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            mtransforms.blended_transform_factory
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                self.xaxis.get_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ self.yaxis.get_transform
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        for line in getattr
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ "lines"
$$$$$$$,
$$$$$$$ []
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$  # Not set during init.
$$$$$$$
            try
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                line._transformed_path.invalidate
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            except AttributeError
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                pass
$$$$$$$

$$$$$$$
    def get_position
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ original=False
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Get a copy of the axes rectangle as a `.Bbox`.
$$$$$$$

$$$$$$$
        Parameters
        ----------
        original 
$$$$$$$
$$$$$$$:
$$$$$$$ bool
$$$$$$$
            If ``True``
$$$$$$$
$$$$$$$,
$$$$$$$ return the original position. Otherwise return the
$$$$$$$
            active position. For an explanation of the positions see
            `.set_position`.
$$$$$$$

$$$$$$$
        Returns
        -------
        `.Bbox`
$$$$$$$

$$$$$$$
        """
        if original
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return self._originalPosition.frozen
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            locator = self.get_axes_locator
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            if not locator
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                self.apply_aspect
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            return self._position.frozen
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def set_position
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ pos
$$$$$$$,
$$$$$$$ which='both'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the axes position.
$$$$$$$

$$$$$$$
        Axes have two position attributes. The 'original' position is the
        position allocated for the Axes. The 'active' position is the
        position the Axes is actually drawn at. These positions are usually
        the same unless a fixed aspect is set to the Axes. See `.set_aspect`
        for details.
$$$$$$$

$$$$$$$
        Parameters
        ----------
        pos 
$$$$$$$
$$$$$$$:
$$$$$$$ [left
$$$$$$$,
$$$$$$$ bottom
$$$$$$$,
$$$$$$$ width
$$$$$$$,
$$$$$$$ height] or `~matplotlib.transforms.Bbox`
$$$$$$$
            The new position of the in `.Figure` coordinates.
$$$$$$$

$$$$$$$
        which 
$$$$$$$
$$$$$$$:
$$$$$$$ {'both'
$$$$$$$,
$$$$$$$ 'active'
$$$$$$$,
$$$$$$$ 'original'}
$$$$$$$,
$$$$$$$ default
$$$$$$$:
$$$$$$$ 'both'
$$$$$$$
            Determines which position variables to change.
$$$$$$$

$$$$$$$
        See Also
        --------
        matplotlib.transforms.Bbox.from_bounds
        matplotlib.transforms.Bbox.from_extents
        """
        self._set_position
$$$$$$$
$$$$$$$(
$$$$$$$pos
$$$$$$$,
$$$$$$$ which=which
$$$$$$$)
$$$$$$$
$$$$$$$
        # because this is being called externally to the library we
        # don't let it be in the layout.
        self.set_in_layout
$$$$$$$
$$$$$$$(
$$$$$$$False
$$$$$$$)
$$$$$$$

$$$$$$$
    def _set_position
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ pos
$$$$$$$,
$$$$$$$ which='both'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Private version of set_position.
$$$$$$$

$$$$$$$
        Call this internally to get the same functionality of `get_position`
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
        but not to take the axis out of the constrained_layout hierarchy.
        """
        if not isinstance
$$$$$$$
$$$$$$$(
$$$$$$$pos
$$$$$$$,
$$$$$$$ mtransforms.BboxBase
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            pos = mtransforms.Bbox.from_bounds
$$$$$$$
$$$$$$$(
$$$$$$$*pos
$$$$$$$)
$$$$$$$
$$$$$$$
        for ax in self._twinned_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if which in 
$$$$$$$
$$$$$$$(
$$$$$$$'both'
$$$$$$$,
$$$$$$$ 'active'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                ax._position.set
$$$$$$$
$$$$$$$(
$$$$$$$pos
$$$$$$$)
$$$$$$$
$$$$$$$
            if which in 
$$$$$$$
$$$$$$$(
$$$$$$$'both'
$$$$$$$,
$$$$$$$ 'original'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                ax._originalPosition.set
$$$$$$$
$$$$$$$(
$$$$$$$pos
$$$$$$$)
$$$$$$$
$$$$$$$
        self.stale = True
$$$$$$$

$$$$$$$
    def reset_position
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Reset the active position to the original position.
$$$$$$$

$$$$$$$
        This resets the a possible position change due to aspect constraints.
        For an explanation of the positions see `.set_position`.
        """
        for ax in self._twinned_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            pos = ax.get_position
$$$$$$$
$$$$$$$(
$$$$$$$original=True
$$$$$$$)
$$$$$$$
$$$$$$$
            ax.set_position
$$$$$$$
$$$$$$$(
$$$$$$$pos
$$$$$$$,
$$$$$$$ which='active'
$$$$$$$)
$$$$$$$

$$$$$$$
    def set_axes_locator
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ locator
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the axes locator.
$$$$$$$

$$$$$$$
        Parameters
        ----------
        locator 
$$$$$$$
$$$$$$$:
$$$$$$$ Callable[[Axes
$$$$$$$,
$$$$$$$ Renderer]
$$$$$$$,
$$$$$$$ Bbox]
$$$$$$$
        """
        self._axes_locator = locator
        self.stale = True
$$$$$$$

$$$$$$$
    def get_axes_locator
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return the axes_locator.
        """
        return self._axes_locator
$$$$$$$

$$$$$$$
    def _set_artist_props
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ a
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """Set the boilerplate props for artists added to axes."""
        a.set_figure
$$$$$$$
$$$$$$$(
$$$$$$$self.figure
$$$$$$$)
$$$$$$$
$$$$$$$
        if not a.is_transform_set
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            a.set_transform
$$$$$$$
$$$$$$$(
$$$$$$$self.transData
$$$$$$$)
$$$$$$$

$$$$$$$
        a.axes = self
        if a.mouseover
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._mouseover_set.add
$$$$$$$
$$$$$$$(
$$$$$$$a
$$$$$$$)
$$$$$$$

$$$$$$$
    def _gen_axes_patch
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Returns
        -------
        Patch
$$$$$$$
            The patch used to draw the background of the axes.  It is also used
            as the clipping path for any data elements on the axes.
$$$$$$$

$$$$$$$
            In the standard axes
$$$$$$$
$$$$$$$,
$$$$$$$ this is a rectangle
$$$$$$$,
$$$$$$$ but in other projections
$$$$$$$
            it may not be.
$$$$$$$

$$$$$$$
        Notes
        -----
        Intended to be overridden by new projection types.
        """
        return mpatches.Rectangle
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$(
$$$$$$$0.0
$$$$$$$,
$$$$$$$ 0.0
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 1.0
$$$$$$$,
$$$$$$$ 1.0
$$$$$$$)
$$$$$$$

$$$$$$$
    def _gen_axes_spines
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ locations=None
$$$$$$$,
$$$$$$$ offset=0.0
$$$$$$$,
$$$$$$$ units='inches'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Returns
        -------
        dict
$$$$$$$
            Mapping of spine names to `.Line2D` or `.Patch` instances that are
            used to draw axes spines.
$$$$$$$

$$$$$$$
            In the standard axes
$$$$$$$
$$$$$$$,
$$$$$$$ spines are single line segments
$$$$$$$,
$$$$$$$ but in other
$$$$$$$
            projections they may not be.
$$$$$$$

$$$$$$$
        Notes
        -----
        Intended to be overridden by new projection types.
        """
        return OrderedDict
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$(
$$$$$$$side
$$$$$$$,
$$$$$$$ mspines.Spine.linear_spine
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ side
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
                           for side in ['left'
$$$$$$$
$$$$$$$,
$$$$$$$ 'right'
$$$$$$$,
$$$$$$$ 'bottom'
$$$$$$$,
$$$$$$$ 'top']
$$$$$$$)
$$$$$$$

$$$$$$$
    def sharex
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ other
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Share the x-axis with *other*.
$$$$$$$

$$$$$$$
        This is equivalent to passing ``sharex=other`` when constructing the
        axes
$$$$$$$
$$$$$$$,
$$$$$$$ and cannot be used if the x-axis is already being shared with
$$$$$$$
        another axes.
        """
        cbook._check_isinstance
$$$$$$$
$$$$$$$(
$$$$$$$_AxesBase
$$$$$$$,
$$$$$$$ other=other
$$$$$$$)
$$$$$$$
$$$$$$$
        if self._sharex is not None and other is not self._sharex
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$"x-axis is already shared"
$$$$$$$)
$$$$$$$
$$$$$$$
        self._shared_x_axes.join
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ other
$$$$$$$)
$$$$$$$
$$$$$$$
        self._sharex = other
        self.xaxis.major = other.xaxis.major  # Ticker instances holding
        self.xaxis.minor = other.xaxis.minor  # locator and formatter.
        x0
$$$$$$$
$$$$$$$,
$$$$$$$ x1 = other.get_xlim
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.set_xlim
$$$$$$$
$$$$$$$(
$$$$$$$x0
$$$$$$$,
$$$$$$$ x1
$$$$$$$,
$$$$$$$ emit=False
$$$$$$$,
$$$$$$$ auto=other.get_autoscalex_on
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.xaxis._scale = other.xaxis._scale
$$$$$$$

$$$$$$$
    def sharey
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ other
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Share the y-axis with *other*.
$$$$$$$

$$$$$$$
        This is equivalent to passing ``sharey=other`` when constructing the
        axes
$$$$$$$
$$$$$$$,
$$$$$$$ and cannot be used if the y-axis is already being shared with
$$$$$$$
        another axes.
        """
        cbook._check_isinstance
$$$$$$$
$$$$$$$(
$$$$$$$_AxesBase
$$$$$$$,
$$$$$$$ other=other
$$$$$$$)
$$$$$$$
$$$$$$$
        if self._sharey is not None and other is not self._sharey
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$"y-axis is already shared"
$$$$$$$)
$$$$$$$
$$$$$$$
        self._shared_y_axes.join
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ other
$$$$$$$)
$$$$$$$
$$$$$$$
        self._sharey = other
        self.yaxis.major = other.yaxis.major  # Ticker instances holding
        self.yaxis.minor = other.yaxis.minor  # locator and formatter.
        y0
$$$$$$$
$$$$$$$,
$$$$$$$ y1 = other.get_ylim
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.set_ylim
$$$$$$$
$$$$$$$(
$$$$$$$y0
$$$$$$$,
$$$$$$$ y1
$$$$$$$,
$$$$$$$ emit=False
$$$$$$$,
$$$$$$$ auto=other.get_autoscaley_on
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.yaxis._scale = other.yaxis._scale
$$$$$$$

$$$$$$$
    def cla
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """Clear the axes."""
        # Note
$$$$$$$
$$$$$$$:
$$$$$$$ this is called by Axes.__init__
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        # stash the current visibility state
        if hasattr
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ 'patch'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            patch_visible = self.patch.get_visible
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            patch_visible = True
$$$$$$$

$$$$$$$
        xaxis_visible = self.xaxis.get_visible
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        yaxis_visible = self.yaxis.get_visible
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        self.xaxis.clear
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.yaxis.clear
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        for name
$$$$$$$
$$$$$$$,
$$$$$$$ spine in self.spines.items
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            spine.clear
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        self.ignore_existing_data_limits = True
        self.callbacks = cbook.CallbackRegistry
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        if self._sharex is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.sharex
$$$$$$$
$$$$$$$(
$$$$$$$self._sharex
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.xaxis._set_scale
$$$$$$$
$$$$$$$(
$$$$$$$'linear'
$$$$$$$)
$$$$$$$
$$$$$$$
            try
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                self.set_xlim
$$$$$$$
$$$$$$$(
$$$$$$$0
$$$$$$$,
$$$$$$$ 1
$$$$$$$)
$$$$$$$
$$$$$$$
            except TypeError
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                pass
$$$$$$$
        if self._sharey is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.sharey
$$$$$$$
$$$$$$$(
$$$$$$$self._sharey
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.yaxis._set_scale
$$$$$$$
$$$$$$$(
$$$$$$$'linear'
$$$$$$$)
$$$$$$$
$$$$$$$
            try
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                self.set_ylim
$$$$$$$
$$$$$$$(
$$$$$$$0
$$$$$$$,
$$$$$$$ 1
$$$$$$$)
$$$$$$$
$$$$$$$
            except TypeError
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                pass
$$$$$$$

$$$$$$$
        # update the minor locator for x and y axis based on rcParams
        if mpl.rcParams['xtick.minor.visible']
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.xaxis.set_minor_locator
$$$$$$$
$$$$$$$(
$$$$$$$mticker.AutoMinorLocator
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if mpl.rcParams['ytick.minor.visible']
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.yaxis.set_minor_locator
$$$$$$$
$$$$$$$(
$$$$$$$mticker.AutoMinorLocator
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        if self._sharex is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._autoscaleXon = True
$$$$$$$
        if self._sharey is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._autoscaleYon = True
$$$$$$$
        self._xmargin = mpl.rcParams['axes.xmargin']
        self._ymargin = mpl.rcParams['axes.ymargin']
        self._tight = None
        self._use_sticky_edges = True
        self._update_transScale
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$  # needed?

$$$$$$$
        self._get_lines = _process_plot_var_args
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$
        self._get_patches_for_fill = _process_plot_var_args
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ 'fill'
$$$$$$$)
$$$$$$$

$$$$$$$
        self._gridOn = mpl.rcParams['axes.grid']
        self.lines = []
        self.patches = []
        self.texts = []
        self.tables = []
        self.artists = []
        self.images = []
        self._mouseover_set = _OrderedSet
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.child_axes = []
        self._current_image = None  # strictly for pyplot via _sci
$$$$$$$
$$$$$$$,
$$$$$$$ _gci
$$$$$$$
        self.legend_ = None
        self.collections = []  # collection.Collection instances
        self.containers = []
$$$$$$$

$$$$$$$
        self.grid
$$$$$$$
$$$$$$$(
$$$$$$$False
$$$$$$$)
$$$$$$$  # Disable grid on init to use rcParameter
$$$$$$$
        self.grid
$$$$$$$
$$$$$$$(
$$$$$$$self._gridOn
$$$$$$$,
$$$$$$$ which=mpl.rcParams['axes.grid.which']
$$$$$$$,
$$$$$$$
$$$$$$$
                  axis=mpl.rcParams['axes.grid.axis']
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        props = font_manager.FontProperties
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            size=mpl.rcParams['axes.titlesize']
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            weight=mpl.rcParams['axes.titleweight']
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        y = mpl.rcParams['axes.titley']
        if y is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            y = 1.0
            self._autotitlepos = True
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._autotitlepos = False
$$$$$$$

$$$$$$$
        self.title = mtext.Text
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            x=0.5
$$$$$$$
$$$$$$$,
$$$$$$$ y=y
$$$$$$$,
$$$$$$$ text=''
$$$$$$$,
$$$$$$$
$$$$$$$
            fontproperties=props
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            verticalalignment='baseline'
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            horizontalalignment='center'
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self._left_title = mtext.Text
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            x=0.0
$$$$$$$
$$$$$$$,
$$$$$$$ y=y
$$$$$$$,
$$$$$$$ text=''
$$$$$$$,
$$$$$$$
$$$$$$$
            fontproperties=props.copy
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            verticalalignment='baseline'
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            horizontalalignment='left'
$$$$$$$
$$$$$$$,
$$$$$$$ 
$$$$$$$)
$$$$$$$
$$$$$$$
        self._right_title = mtext.Text
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            x=1.0
$$$$$$$
$$$$$$$,
$$$$$$$ y=y
$$$$$$$,
$$$$$$$ text=''
$$$$$$$,
$$$$$$$
$$$$$$$
            fontproperties=props.copy
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            verticalalignment='baseline'
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            horizontalalignment='right'
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        title_offset_points = mpl.rcParams['axes.titlepad']
        # refactor this out so it can be called in ax.set_title if
        # pad argument used...
        self._set_title_offset_trans
$$$$$$$
$$$$$$$(
$$$$$$$title_offset_points
$$$$$$$)
$$$$$$$

$$$$$$$
        for _title in 
$$$$$$$
$$$$$$$(
$$$$$$$self.title
$$$$$$$,
$$$$$$$ self._left_title
$$$$$$$,
$$$$$$$ self._right_title
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._set_artist_props
$$$$$$$
$$$$$$$(
$$$$$$$_title
$$$$$$$)
$$$$$$$

$$$$$$$
        # The patch draws the background of the axes.  We want this to be below
        # the other artists.  We use the frame to draw the edges so we are
        # setting the edgecolor to None.
        self.patch = self._gen_axes_patch
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.patch.set_figure
$$$$$$$
$$$$$$$(
$$$$$$$self.figure
$$$$$$$)
$$$$$$$
$$$$$$$
        self.patch.set_facecolor
$$$$$$$
$$$$$$$(
$$$$$$$self._facecolor
$$$$$$$)
$$$$$$$
$$$$$$$
        self.patch.set_edgecolor
$$$$$$$
$$$$$$$(
$$$$$$$'None'
$$$$$$$)
$$$$$$$
$$$$$$$
        self.patch.set_linewidth
$$$$$$$
$$$$$$$(
$$$$$$$0
$$$$$$$)
$$$$$$$
$$$$$$$
        self.patch.set_transform
$$$$$$$
$$$$$$$(
$$$$$$$self.transAxes
$$$$$$$)
$$$$$$$

$$$$$$$
        self.set_axis_on
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        self.xaxis.set_clip_path
$$$$$$$
$$$$$$$(
$$$$$$$self.patch
$$$$$$$)
$$$$$$$
$$$$$$$
        self.yaxis.set_clip_path
$$$$$$$
$$$$$$$(
$$$$$$$self.patch
$$$$$$$)
$$$$$$$

$$$$$$$
        self._shared_x_axes.clean
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self._shared_y_axes.clean
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if self._sharex is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.xaxis.set_visible
$$$$$$$
$$$$$$$(
$$$$$$$xaxis_visible
$$$$$$$)
$$$$$$$
$$$$$$$
            self.patch.set_visible
$$$$$$$
$$$$$$$(
$$$$$$$patch_visible
$$$$$$$)
$$$$$$$
$$$$$$$
        if self._sharey is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.yaxis.set_visible
$$$$$$$
$$$$$$$(
$$$$$$$yaxis_visible
$$$$$$$)
$$$$$$$
$$$$$$$
            self.patch.set_visible
$$$$$$$
$$$$$$$(
$$$$$$$patch_visible
$$$$$$$)
$$$$$$$

$$$$$$$
        self.stale = True
$$$$$$$

$$$$$$$
    def clear
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """Clear the axes."""
        self.cla
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_facecolor
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """Get the facecolor of the Axes."""
        return self.patch.get_facecolor
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def set_facecolor
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ color
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the facecolor of the Axes.
$$$$$$$

$$$$$$$
        Parameters
        ----------
        color 
$$$$$$$
$$$$$$$:
$$$$$$$ color
$$$$$$$
        """
        self._facecolor = color
        self.stale = True
        return self.patch.set_facecolor
$$$$$$$
$$$$$$$(
$$$$$$$color
$$$$$$$)
$$$$$$$

$$$$$$$
    def _set_title_offset_trans
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ title_offset_points
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the offset for the title either from 
$$$$$$$
$$$$$$$:
$$$$$$$rc
$$$$$$$:
$$$$$$$`axes.titlepad`
$$$$$$$
        or from set_title kwarg ``pad``.
        """
        self.titleOffsetTrans = mtransforms.ScaledTranslation
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                0.0
$$$$$$$
$$$$$$$,
$$$$$$$ title_offset_points / 72
$$$$$$$,
$$$$$$$
$$$$$$$
                self.figure.dpi_scale_trans
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        for _title in 
$$$$$$$
$$$$$$$(
$$$$$$$self.title
$$$$$$$,
$$$$$$$ self._left_title
$$$$$$$,
$$$$$$$ self._right_title
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            _title.set_transform
$$$$$$$
$$$$$$$(
$$$$$$$self.transAxes + self.titleOffsetTrans
$$$$$$$)
$$$$$$$
$$$$$$$
            _title.set_clip_box
$$$$$$$
$$$$$$$(
$$$$$$$None
$$$$$$$)
$$$$$$$

$$$$$$$
    def set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ *args
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the property cycle of the Axes.
$$$$$$$

$$$$$$$
        The property cycle controls the style properties such as color
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
        marker and linestyle of future plot commands. The style properties
        of data already added to the Axes are not modified.
$$$$$$$

$$$$$$$
        Call signatures
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
          set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$cycler
$$$$$$$)
$$$$$$$
$$$$$$$
          set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$label=values[
$$$$$$$,
$$$$$$$ label2=values2[
$$$$$$$,
$$$$$$$ ...]]
$$$$$$$)
$$$$$$$
$$$$$$$
          set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$label
$$$$$$$,
$$$$$$$ values
$$$$$$$)
$$$$$$$

$$$$$$$
        Form 1 sets given `~cycler.Cycler` object.
$$$$$$$

$$$$$$$
        Form 2 creates a `~cycler.Cycler` which cycles over one or more
        properties simultaneously and set it as the property cycle of the
        axes. If multiple properties are given
$$$$$$$
$$$$$$$,
$$$$$$$ their value lists must have
$$$$$$$
        the same length. This is just a shortcut for explicitly creating a
        cycler and passing it to the function
$$$$$$$
$$$$$$$,
$$$$$$$ i.e. it's short for
$$$$$$$
        ``set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$cycler
$$$$$$$(
$$$$$$$label=values label2=values2
$$$$$$$,
$$$$$$$ ...
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$``.

$$$$$$$
        Form 3 creates a `~cycler.Cycler` for a single property and set it
        as the property cycle of the axes. This form exists for compatibility
        with the original `cycler.cycler` interface. Its use is discouraged
        in favor of the kwarg form
$$$$$$$
$$$$$$$,
$$$$$$$ i.e. ``set_prop_cycle
$$$$$$$(
$$$$$$$label=values
$$$$$$$)
$$$$$$$``.

$$$$$$$
        Parameters
        ----------
        cycler 
$$$$$$$
$$$$$$$:
$$$$$$$ Cycler
$$$$$$$
            Set the given Cycler. *None* resets to the cycle defined by the
            current style.
$$$$$$$

$$$$$$$
        label 
$$$$$$$
$$$$$$$:
$$$$$$$ str
$$$$$$$
            The property key. Must be a valid `.Artist` property.
            For example
$$$$$$$
$$$$$$$,
$$$$$$$ 'color' or 'linestyle'. Aliases are allowed
$$$$$$$,
$$$$$$$
$$$$$$$
            such as 'c' for 'color' and 'lw' for 'linewidth'.
$$$$$$$

$$$$$$$
        values 
$$$$$$$
$$$$$$$:
$$$$$$$ iterable
$$$$$$$
            Finite-length iterable of the property values. These values
            are validated and will raise a ValueError if invalid.
$$$$$$$

$$$$$$$
        See Also
        --------
        matplotlib.rcsetup.cycler
$$$$$$$
            Convenience function for creating validated cyclers for properties.
$$$$$$$
        cycler.cycler
$$$$$$$
            The original function for creating unvalidated cyclers.
$$$$$$$

$$$$$$$
        Examples
        --------
        Setting the property cycle for a single property
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
        >>> ax.set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$color=['red'
$$$$$$$,
$$$$$$$ 'green'
$$$$$$$,
$$$$$$$ 'blue']
$$$$$$$)
$$$$$$$

$$$$$$$
        Setting the property cycle for simultaneously cycling over multiple
        properties 
$$$$$$$
$$$$$$$(
$$$$$$$e.g. red circle
$$$$$$$,
$$$$$$$ green plus
$$$$$$$,
$$$$$$$ blue cross
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
        >>> ax.set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$color=['red'
$$$$$$$,
$$$$$$$ 'green'
$$$$$$$,
$$$$$$$ 'blue']
$$$$$$$,
$$$$$$$
$$$$$$$
        ...                   marker=['o'
$$$$$$$
$$$$$$$,
$$$$$$$ '+'
$$$$$$$,
$$$$$$$ 'x']
$$$$$$$)
$$$$$$$

$$$$$$$
        """
        if args and kwargs
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise TypeError
$$$$$$$
$$$$$$$(
$$$$$$$"Cannot supply both positional and keyword "
$$$$$$$
                            "arguments to this method."
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        # Can't do `args == 
$$$$$$$
$$$$$$$(
$$$$$$$None
$$$$$$$,
$$$$$$$
$$$$$$$)
$$$$$$$` as that crashes cycler.
$$$$$$$
        if len
$$$$$$$
$$$$$$$(
$$$$$$$args
$$$$$$$)
$$$$$$$ == 1 and args[0] is None
$$$$$$$:
$$$$$$$
$$$$$$$
            prop_cycle = None
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            prop_cycle = cycler
$$$$$$$
$$$$$$$(
$$$$$$$*args
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$
$$$$$$$
        self._get_lines.set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$prop_cycle
$$$$$$$)
$$$$$$$
$$$$$$$
        self._get_patches_for_fill.set_prop_cycle
$$$$$$$
$$$$$$$(
$$$$$$$prop_cycle
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_aspect
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        return self._aspect
$$$$$$$

$$$$$$$
    def set_aspect
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ aspect
$$$$$$$,
$$$$$$$ adjustable=None
$$$$$$$,
$$$$$$$ anchor=None
$$$$$$$,
$$$$$$$ share=False
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the aspect of the axis scaling
$$$$$$$
$$$$$$$,
$$$$$$$ i.e. the ratio of y-unit to x-unit.

$$$$$$$
        Parameters
        ----------
        aspect 
$$$$$$$
$$$$$$$:
$$$$$$$ {'auto'} or num
$$$$$$$
            Possible values
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
            ========   =================================================
            value      description
            ========   =================================================
            'auto'     automatic; fill the position rectangle with data.
            num        a circle will be stretched such that the height
$$$$$$$
                       is *num* times the width.  'equal' is a synonym
                       for ``aspect=1``
$$$$$$$
$$$$$$$,
$$$$$$$ i.e. same scaling for x and y.
$$$$$$$
            ========   =================================================
$$$$$$$

$$$$$$$
        adjustable 
$$$$$$$
$$$$$$$:
$$$$$$$ None or {'box'
$$$$$$$,
$$$$$$$ 'datalim'}
$$$$$$$,
$$$$$$$ optional
$$$$$$$
            If not ``None``
$$$$$$$
$$$$$$$,
$$$$$$$ this defines which parameter will be adjusted to
$$$$$$$
            meet the required aspect. See `.set_adjustable` for further
            details.
$$$$$$$

$$$$$$$
        anchor 
$$$$$$$
$$$$$$$:
$$$$$$$ None or str or 2-tuple of float
$$$$$$$,
$$$$$$$ optional
$$$$$$$
            If not ``None``
$$$$$$$
$$$$$$$,
$$$$$$$ this defines where the Axes will be drawn if there
$$$$$$$
            is extra space due to aspect constraints. The most common way to
            to specify the anchor are abbreviations of cardinal directions
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
            =====   =====================
            value   description
            =====   =====================
            'C'     centered
            'SW'    lower left corner
            'S'     middle of bottom edge
            'SE'    lower right corner
            etc.
            =====   =====================
$$$$$$$

$$$$$$$
            See `.set_anchor` for further details.
$$$$$$$

$$$$$$$
        share 
$$$$$$$
$$$$$$$:
$$$$$$$ bool
$$$$$$$,
$$$$$$$ default
$$$$$$$:
$$$$$$$ False
$$$$$$$
            If ``True``
$$$$$$$
$$$$$$$,
$$$$$$$ apply the settings to all shared Axes.

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_adjustable
$$$$$$$
            Set how the Axes adjusts to achieve the required aspect ratio.
$$$$$$$
        matplotlib.axes.Axes.set_anchor
$$$$$$$
            Set the position in case of extra space.
$$$$$$$
        """
        if cbook._str_equal
$$$$$$$
$$$$$$$(
$$$$$$$aspect
$$$$$$$,
$$$$$$$ 'equal'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            aspect = 1
$$$$$$$
        if not cbook._str_equal
$$$$$$$
$$$$$$$(
$$$$$$$aspect
$$$$$$$,
$$$$$$$ 'auto'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            aspect = float
$$$$$$$
$$$$$$$(
$$$$$$$aspect
$$$$$$$)
$$$$$$$  # raise ValueError if necessary

$$$$$$$
        if share
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            axes = {*self._shared_x_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                    *self._shared_y_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$}
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            axes = [self]
$$$$$$$

$$$$$$$
        for ax in axes
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            ax._aspect = aspect
$$$$$$$

$$$$$$$
        if adjustable is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            adjustable = self._adjustable
$$$$$$$
        self.set_adjustable
$$$$$$$
$$$$$$$(
$$$$$$$adjustable
$$$$$$$,
$$$$$$$ share=share
$$$$$$$)
$$$$$$$  # Handle sharing.

$$$$$$$
        if anchor is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self.set_anchor
$$$$$$$
$$$$$$$(
$$$$$$$anchor
$$$$$$$,
$$$$$$$ share=share
$$$$$$$)
$$$$$$$
$$$$$$$
        self.stale = True
$$$$$$$

$$$$$$$
    def get_adjustable
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return whether the Axes will adjust its physical dimension 
$$$$$$$
$$$$$$$(
$$$$$$$'box'
$$$$$$$)
$$$$$$$ or
$$$$$$$
        its data limits 
$$$$$$$
$$$$$$$(
$$$$$$$'datalim'
$$$$$$$)
$$$$$$$ to achieve the desired aspect ratio.

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_adjustable
$$$$$$$
            Set how the Axes adjusts to achieve the required aspect ratio.
$$$$$$$
        matplotlib.axes.Axes.set_aspect
$$$$$$$
            For a description of aspect handling.
$$$$$$$
        """
        return self._adjustable
$$$$$$$

$$$$$$$
    def set_adjustable
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ adjustable
$$$$$$$,
$$$$$$$ share=False
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set how the Axes adjusts to achieve the required aspect ratio.
$$$$$$$

$$$$$$$
        Parameters
        ----------
        adjustable 
$$$$$$$
$$$$$$$:
$$$$$$$ {'box'
$$$$$$$,
$$$$$$$ 'datalim'}
$$$$$$$
            If 'box'
$$$$$$$
$$$$$$$,
$$$$$$$ change the physical dimensions of the Axes.
$$$$$$$
            If 'datalim'
$$$$$$$
$$$$$$$,
$$$$$$$ change the ``x`` or ``y`` data limits.

$$$$$$$
        share 
$$$$$$$
$$$$$$$:
$$$$$$$ bool
$$$$$$$,
$$$$$$$ default
$$$$$$$:
$$$$$$$ False
$$$$$$$
            If ``True``
$$$$$$$
$$$$$$$,
$$$$$$$ apply the settings to all shared Axes.

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_aspect
$$$$$$$
            For a description of aspect handling.
$$$$$$$

$$$$$$$
        Notes
        -----
        Shared Axes 
$$$$$$$
$$$$$$$(
$$$$$$$of which twinned Axes are a special case
$$$$$$$)
$$$$$$$
$$$$$$$
        impose restrictions on how aspect ratios can be imposed.
        For twinned Axes
$$$$$$$
$$$$$$$,
$$$$$$$ use 'datalim'.  For Axes that share both
$$$$$$$
        x and y
$$$$$$$
$$$$$$$,
$$$$$$$ use 'box'.  Otherwise
$$$$$$$,
$$$$$$$ either 'datalim' or 'box'
$$$$$$$
        may be used.  These limitations are partly a requirement
        to avoid over-specification
$$$$$$$
$$$$$$$,
$$$$$$$ and partly a result of the
$$$$$$$
        particular implementation we are currently using
$$$$$$$
$$$$$$$,
$$$$$$$ in
$$$$$$$
        which the adjustments for aspect ratios are done sequentially
        and independently on each Axes as it is drawn.
        """
        _api.check_in_list
$$$$$$$
$$$$$$$(
$$$$$$$["box"
$$$$$$$,
$$$$$$$ "datalim"]
$$$$$$$,
$$$$$$$ adjustable=adjustable
$$$$$$$)
$$$$$$$
$$$$$$$
        if share
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            axs = {*self._shared_x_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                   *self._shared_y_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$}
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            axs = [self]
$$$$$$$
        if 
$$$$$$$
$$$$$$$(
$$$$$$$adjustable == "datalim"
$$$$$$$
                and any
$$$$$$$
$$$$$$$(
$$$$$$$getattr
$$$$$$$(
$$$$$$$ax.get_data_ratio
$$$$$$$,
$$$$$$$ "__func__"
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$
$$$$$$$
                        != _AxesBase.get_data_ratio
                        for ax in axs
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            # Limits adjustment by apply_aspect assumes that the axes' aspect
            # ratio can be computed from the data limits and scales.
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$"Cannot set axes adjustable to 'datalim' for "
$$$$$$$
                             "Axes which override 'get_data_ratio'"
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        for ax in axs
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            ax._adjustable = adjustable
$$$$$$$
        self.stale = True
$$$$$$$

$$$$$$$
    def get_box_aspect
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return the axes box aspect
$$$$$$$
$$$$$$$,
$$$$$$$ i.e. the ratio of height to width.

$$$$$$$
        The box aspect is ``None`` 
$$$$$$$
$$$$$$$(
$$$$$$$i.e. chosen depending on the available
$$$$$$$
        figure space
$$$$$$$
$$$$$$$)
$$$$$$$ unless explicitly specified.

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_box_aspect
$$$$$$$
            for a description of box aspect.
$$$$$$$
        matplotlib.axes.Axes.set_aspect
$$$$$$$
            for a description of aspect handling.
$$$$$$$
        """
        return self._box_aspect
$$$$$$$

$$$$$$$
    def set_box_aspect
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ aspect=None
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the axes box aspect
$$$$$$$
$$$$$$$,
$$$$$$$ i.e. the ratio of height to width.

$$$$$$$
        This defines the aspect of the axes in figure space and is not to be
        confused with the data aspect 
$$$$$$$
$$$$$$$(
$$$$$$$see `~.Axes.set_aspect`
$$$$$$$)
$$$$$$$.

$$$$$$$
        Parameters
        ----------
        aspect 
$$$$$$$
$$$$$$$:
$$$$$$$ float or None
$$$$$$$
            Changes the physical dimensions of the Axes
$$$$$$$
$$$$$$$,
$$$$$$$ such that the ratio
$$$$$$$
            of the axes height to the axes width in physical units is equal to
            *aspect*. Defining a box aspect will change the *adjustable*
            property to 'datalim' 
$$$$$$$
$$$$$$$(
$$$$$$$see `~.Axes.set_adjustable`
$$$$$$$)
$$$$$$$.

$$$$$$$
            *None* will disable a fixed box aspect so that height and width
            of the axes are chosen independently.
$$$$$$$

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_aspect
$$$$$$$
            for a description of aspect handling.
$$$$$$$
        """
        axs = {*self._twinned_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
               *self._twinned_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$}

$$$$$$$
        if aspect is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            aspect = float
$$$$$$$
$$$$$$$(
$$$$$$$aspect
$$$$$$$)
$$$$$$$
$$$$$$$
            # when box_aspect is set to other than None`
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
            # adjustable must be "datalim"
            for ax in axs
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                ax.set_adjustable
$$$$$$$
$$$$$$$(
$$$$$$$"datalim"
$$$$$$$)
$$$$$$$

$$$$$$$
        for ax in axs
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            ax._box_aspect = aspect
            ax.stale = True
$$$$$$$

$$$$$$$
    def get_anchor
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Get the anchor location.
$$$$$$$

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_anchor
$$$$$$$
            for a description of the anchor.
$$$$$$$
        matplotlib.axes.Axes.set_aspect
$$$$$$$
            for a description of aspect handling.
$$$$$$$
        """
        return self._anchor
$$$$$$$

$$$$$$$
    def set_anchor
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ anchor
$$$$$$$,
$$$$$$$ share=False
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Define the anchor location.
$$$$$$$

$$$$$$$
        The actual drawing area 
$$$$$$$
$$$$$$$(
$$$$$$$active position
$$$$$$$)
$$$$$$$ of the Axes may be smaller
$$$$$$$
        than the Bbox 
$$$$$$$
$$$$$$$(
$$$$$$$original position
$$$$$$$)
$$$$$$$ when a fixed aspect is required. The
$$$$$$$
        anchor defines where the drawing area will be located within the
        available space.
$$$$$$$

$$$$$$$
        Parameters
        ----------
        anchor 
$$$$$$$
$$$$$$$:
$$$$$$$ 2-tuple of floats or {'C'
$$$$$$$,
$$$$$$$ 'SW'
$$$$$$$,
$$$$$$$ 'S'
$$$$$$$,
$$$$$$$ 'SE'
$$$$$$$,
$$$$$$$ ...}
$$$$$$$
            The anchor position may be either
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
            - a sequence 
$$$$$$$
$$$$$$$(
$$$$$$$*cx*
$$$$$$$,
$$$$$$$ *cy*
$$$$$$$)
$$$$$$$. *cx* and *cy* may range from 0
$$$$$$$
              to 1
$$$$$$$
$$$$$$$,
$$$$$$$ where 0 is left or bottom and 1 is right or top.

$$$$$$$
            - a string using cardinal directions as abbreviation
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
              - 'C' for centered
              - 'S' 
$$$$$$$
$$$$$$$(
$$$$$$$south
$$$$$$$)
$$$$$$$ for bottom-center
$$$$$$$
              - 'SW' 
$$$$$$$
$$$$$$$(
$$$$$$$south west
$$$$$$$)
$$$$$$$ for bottom-left
$$$$$$$
              - etc.
$$$$$$$

$$$$$$$
              Here is an overview of the possible positions
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
              +------+------+------+
              | 'NW' | 'N'  | 'NE' |
              +------+------+------+
              | 'W'  | 'C'  | 'E'  |
              +------+------+------+
              | 'SW' | 'S'  | 'SE' |
              +------+------+------+
$$$$$$$

$$$$$$$
        share 
$$$$$$$
$$$$$$$:
$$$$$$$ bool
$$$$$$$,
$$$$$$$ default
$$$$$$$:
$$$$$$$ False
$$$$$$$
            If ``True``
$$$$$$$
$$$$$$$,
$$$$$$$ apply the settings to all shared Axes.

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_aspect
$$$$$$$
            for a description of aspect handling.
$$$$$$$
        """
        if not 
$$$$$$$
$$$$$$$(
$$$$$$$anchor in mtransforms.Bbox.coefs or len
$$$$$$$(
$$$$$$$anchor
$$$$$$$)
$$$$$$$ == 2
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$'argument must be among %s' %
$$$$$$$
                             '
$$$$$$$
$$$$$$$,
$$$$$$$ '.join
$$$$$$$(
$$$$$$$mtransforms.Bbox.coefs
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if share
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            axes = {*self._shared_x_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                    *self._shared_y_axes.get_siblings
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$}
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            axes = [self]
$$$$$$$
        for ax in axes
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            ax._anchor = anchor
$$$$$$$

$$$$$$$
        self.stale = True
$$$$$$$

$$$$$$$
    def get_data_ratio
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return the aspect ratio of the scaled data.
$$$$$$$

$$$$$$$
        Notes
        -----
        This method is intended to be overridden by new projection types.
        """
        txmin
$$$$$$$
$$$$$$$,
$$$$$$$ txmax = self.xaxis.get_transform
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.transform
$$$$$$$(
$$$$$$$self.get_xbound
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        tymin
$$$$$$$
$$$$$$$,
$$$$$$$ tymax = self.yaxis.get_transform
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.transform
$$$$$$$(
$$$$$$$self.get_ybound
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        xsize = max
$$$$$$$
$$$$$$$(
$$$$$$$abs
$$$$$$$(
$$$$$$$txmax - txmin
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 1e-30
$$$$$$$)
$$$$$$$
$$$$$$$
        ysize = max
$$$$$$$
$$$$$$$(
$$$$$$$abs
$$$$$$$(
$$$$$$$tymax - tymin
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 1e-30
$$$$$$$)
$$$$$$$
$$$$$$$
        return ysize / xsize
$$$$$$$

$$$$$$$
    @cbook.deprecated
$$$$$$$
$$$$$$$(
$$$$$$$"3.2"
$$$$$$$)
$$$$$$$
$$$$$$$
    def get_data_ratio_log
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return the aspect ratio of the raw data in log scale.
$$$$$$$

$$$$$$$
        Notes
        -----
        Will be used when both axis are in log scale.
        """
        xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax = self.get_xbound
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        ymin
$$$$$$$
$$$$$$$,
$$$$$$$ ymax = self.get_ybound
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        xsize = max
$$$$$$$
$$$$$$$(
$$$$$$$abs
$$$$$$$(
$$$$$$$math.log10
$$$$$$$(
$$$$$$$xmax
$$$$$$$)
$$$$$$$ - math.log10
$$$$$$$(
$$$$$$$xmin
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 1e-30
$$$$$$$)
$$$$$$$
$$$$$$$
        ysize = max
$$$$$$$
$$$$$$$(
$$$$$$$abs
$$$$$$$(
$$$$$$$math.log10
$$$$$$$(
$$$$$$$ymax
$$$$$$$)
$$$$$$$ - math.log10
$$$$$$$(
$$$$$$$ymin
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 1e-30
$$$$$$$)
$$$$$$$

$$$$$$$
        return ysize / xsize
$$$$$$$

$$$$$$$
    def apply_aspect
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ position=None
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Adjust the Axes for a specified data aspect ratio.
$$$$$$$

$$$$$$$
        Depending on `.get_adjustable` this will modify either the
        Axes box 
$$$$$$$
$$$$$$$(
$$$$$$$position
$$$$$$$)
$$$$$$$ or the view limits. In the former case
$$$$$$$,
$$$$$$$
$$$$$$$
        `~matplotlib.axes.Axes.get_anchor` will affect the position.
$$$$$$$

$$$$$$$
        Notes
        -----
        This is called automatically when each Axes is drawn.  You may need
        to call it yourself if you need to update the Axes position and/or
        view limits before the Figure is drawn.
$$$$$$$

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_aspect
$$$$$$$
            For a description of aspect ratio handling.
$$$$$$$
        matplotlib.axes.Axes.set_adjustable
$$$$$$$
            Set how the Axes adjusts to achieve the required aspect ratio.
$$$$$$$
        matplotlib.axes.Axes.set_anchor
$$$$$$$
            Set the position in case of extra space.
$$$$$$$
        """
        if position is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            position = self.get_position
$$$$$$$
$$$$$$$(
$$$$$$$original=True
$$$$$$$)
$$$$$$$

$$$$$$$
        aspect = self.get_aspect
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        if aspect == 'auto' and self._box_aspect is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._set_position
$$$$$$$
$$$$$$$(
$$$$$$$position
$$$$$$$,
$$$$$$$ which='active'
$$$$$$$)
$$$$$$$
$$$$$$$
            return
$$$$$$$

$$$$$$$
        trans = self.get_figure
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.transSubfigure
$$$$$$$
        bb = mtransforms.Bbox.from_bounds
$$$$$$$
$$$$$$$(
$$$$$$$0
$$$$$$$,
$$$$$$$ 0
$$$$$$$,
$$$$$$$ 1
$$$$$$$,
$$$$$$$ 1
$$$$$$$)
$$$$$$$.transformed
$$$$$$$(
$$$$$$$trans
$$$$$$$)
$$$$$$$
$$$$$$$
        # this is the physical aspect of the panel 
$$$$$$$
$$$$$$$(
$$$$$$$or figure
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        fig_aspect = bb.height / bb.width
$$$$$$$

$$$$$$$
        if self._adjustable == 'box'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if self in self._twinned_axes
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise RuntimeError
$$$$$$$
$$$$$$$(
$$$$$$$"Adjustable 'box' is not allowed in a "
$$$$$$$
                                   "twinned Axes; use 'datalim' instead"
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            box_aspect = aspect * self.get_data_ratio
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            pb = position.frozen
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            pb1 = pb.shrunk_to_aspect
$$$$$$$
$$$$$$$(
$$$$$$$box_aspect
$$$$$$$,
$$$$$$$ pb
$$$$$$$,
$$$$$$$ fig_aspect
$$$$$$$)
$$$$$$$
$$$$$$$
            self._set_position
$$$$$$$
$$$$$$$(
$$$$$$$pb1.anchored
$$$$$$$(
$$$$$$$self.get_anchor
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ pb
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 'active'
$$$$$$$)
$$$$$$$
$$$$$$$
            return
$$$$$$$

$$$$$$$
        # The following is only seen if self._adjustable == 'datalim'
        if self._box_aspect is not None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            pb = position.frozen
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            pb1 = pb.shrunk_to_aspect
$$$$$$$
$$$$$$$(
$$$$$$$self._box_aspect
$$$$$$$,
$$$$$$$ pb
$$$$$$$,
$$$$$$$ fig_aspect
$$$$$$$)
$$$$$$$
$$$$$$$
            self._set_position
$$$$$$$
$$$$$$$(
$$$$$$$pb1.anchored
$$$$$$$(
$$$$$$$self.get_anchor
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ pb
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 'active'
$$$$$$$)
$$$$$$$
$$$$$$$
            if aspect == "auto"
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                return
$$$$$$$

$$$$$$$
        # reset active to original in case it had been changed by prior use
        # of 'box'
        if self._box_aspect is None
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            self._set_position
$$$$$$$
$$$$$$$(
$$$$$$$position
$$$$$$$,
$$$$$$$ which='active'
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            position = pb1.anchored
$$$$$$$
$$$$$$$(
$$$$$$$self.get_anchor
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ pb
$$$$$$$)
$$$$$$$

$$$$$$$
        x_trf = self.xaxis.get_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        y_trf = self.yaxis.get_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax = x_trf.transform
$$$$$$$(
$$$$$$$self.get_xbound
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        ymin
$$$$$$$
$$$$$$$,
$$$$$$$ ymax = y_trf.transform
$$$$$$$(
$$$$$$$self.get_ybound
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        xsize = max
$$$$$$$
$$$$$$$(
$$$$$$$abs
$$$$$$$(
$$$$$$$xmax - xmin
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 1e-30
$$$$$$$)
$$$$$$$
$$$$$$$
        ysize = max
$$$$$$$
$$$$$$$(
$$$$$$$abs
$$$$$$$(
$$$$$$$ymax - ymin
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 1e-30
$$$$$$$)
$$$$$$$

$$$$$$$
        box_aspect = fig_aspect * 
$$$$$$$
$$$$$$$(
$$$$$$$position.height / position.width
$$$$$$$)
$$$$$$$
$$$$$$$
        data_ratio = box_aspect / aspect
$$$$$$$

$$$$$$$
        y_expander = data_ratio * xsize / ysize - 1
        # If y_expander > 0
$$$$$$$
$$$$$$$,
$$$$$$$ the dy/dx viewLim ratio needs to increase
$$$$$$$
        if abs
$$$$$$$
$$$$$$$(
$$$$$$$y_expander
$$$$$$$)
$$$$$$$ < 0.005
$$$$$$$:
$$$$$$$
$$$$$$$
            return
$$$$$$$

$$$$$$$
        dL = self.dataLim
        x0
$$$$$$$
$$$$$$$,
$$$$$$$ x1 = x_trf.transform
$$$$$$$(
$$$$$$$dL.intervalx
$$$$$$$)
$$$$$$$
$$$$$$$
        y0
$$$$$$$
$$$$$$$,
$$$$$$$ y1 = y_trf.transform
$$$$$$$(
$$$$$$$dL.intervaly
$$$$$$$)
$$$$$$$
$$$$$$$
        xr = 1.05 * 
$$$$$$$
$$$$$$$(
$$$$$$$x1 - x0
$$$$$$$)
$$$$$$$
$$$$$$$
        yr = 1.05 * 
$$$$$$$
$$$$$$$(
$$$$$$$y1 - y0
$$$$$$$)
$$$$$$$

$$$$$$$
        xmarg = xsize - xr
        ymarg = ysize - yr
        Ysize = data_ratio * xsize
        Xsize = ysize / data_ratio
        Xmarg = Xsize - xr
        Ymarg = Ysize - yr
        # Setting these targets to
$$$$$$$
$$$$$$$,
$$$$$$$ e.g.
$$$$$$$,
$$$$$$$ 0.05*xr does not seem to help.
$$$$$$$
        xm = 0
        ym = 0
$$$$$$$

$$$$$$$
        shared_x = self in self._shared_x_axes
        shared_y = self in self._shared_y_axes
        # Not sure whether we need this check
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        if shared_x and shared_y
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise RuntimeError
$$$$$$$
$$$$$$$(
$$$$$$$"adjustable='datalim' is not allowed when both "
$$$$$$$
                               "axes are shared"
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        # If y is shared
$$$$$$$
$$$$$$$,
$$$$$$$ then we are only allowed to change x
$$$$$$$,
$$$$$$$ etc.
$$$$$$$
        if shared_y
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            adjust_y = False
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if xmarg > xm and ymarg > ym
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                adjy = 
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$(
$$$$$$$Ymarg > 0 and y_expander < 0
$$$$$$$)
$$$$$$$ or
$$$$$$$
                        
$$$$$$$
$$$$$$$(
$$$$$$$Xmarg < 0 and y_expander > 0
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                adjy = y_expander > 0
$$$$$$$
            adjust_y = shared_x or adjy  # 
$$$$$$$
$$$$$$$(
$$$$$$$Ymarg > xmarg
$$$$$$$)
$$$$$$$

$$$$$$$
        if adjust_y
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            yc = 0.5 * 
$$$$$$$
$$$$$$$(
$$$$$$$ymin + ymax
$$$$$$$)
$$$$$$$
$$$$$$$
            y0 = yc - Ysize / 2.0
            y1 = yc + Ysize / 2.0
            self.set_ybound
$$$$$$$
$$$$$$$(
$$$$$$$y_trf.inverted
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.transform
$$$$$$$(
$$$$$$$[y0
$$$$$$$,
$$$$$$$ y1]
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            xc = 0.5 * 
$$$$$$$
$$$$$$$(
$$$$$$$xmin + xmax
$$$$$$$)
$$$$$$$
$$$$$$$
            x0 = xc - Xsize / 2.0
            x1 = xc + Xsize / 2.0
            self.set_xbound
$$$$$$$
$$$$$$$(
$$$$$$$x_trf.inverted
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$.transform
$$$$$$$(
$$$$$$$[x0
$$$$$$$,
$$$$$$$ x1]
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def axis
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ *args
$$$$$$$,
$$$$$$$ emit=True
$$$$$$$,
$$$$$$$ **kwargs
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Convenience method to get or set some axis properties.
$$$$$$$

$$$$$$$
        Call signatures
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
          xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax = axis
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
          xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax = axis
$$$$$$$(
$$$$$$$[xmin
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax]
$$$$$$$)
$$$$$$$
$$$$$$$
          xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax = axis
$$$$$$$(
$$$$$$$option
$$$$$$$)
$$$$$$$
$$$$$$$
          xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax = axis
$$$$$$$(
$$$$$$$**kwargs
$$$$$$$)
$$$$$$$

$$$$$$$
        Parameters
        ----------
        xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax 
$$$$$$$:
$$$$$$$ float
$$$$$$$,
$$$$$$$ optional
$$$$$$$
            The axis limits to be set.  This can also be achieved using 
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
                ax.set
$$$$$$$
$$$$$$$(
$$$$$$$xlim=
$$$$$$$(
$$$$$$$xmin
$$$$$$$,
$$$$$$$ xmax
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ ylim=
$$$$$$$(
$$$$$$$ymin
$$$$$$$,
$$$$$$$ ymax
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        option 
$$$$$$$
$$$$$$$:
$$$$$$$ bool or str
$$$$$$$
            If a bool
$$$$$$$
$$$$$$$,
$$$$$$$ turns axis lines and labels on or off. If a string
$$$$$$$,
$$$$$$$
$$$$$$$
            possible values are
$$$$$$$
$$$$$$$:
$$$$$$$

$$$$$$$
            ======== ==========================================================
            Value    Description
            ======== ==========================================================
            'on'     Turn on axis lines and labels. Same as ``True``.
            'off'    Turn off axis lines and labels. Same as ``False``.
            'equal'  Set equal scaling 
$$$$$$$
$$$$$$$(
$$$$$$$i.e.
$$$$$$$,
$$$$$$$ make circles circular
$$$$$$$)
$$$$$$$ by
$$$$$$$
                     changing axis limits. This is the same as
                     ``ax.set_aspect
$$$$$$$
$$$$$$$(
$$$$$$$'equal'
$$$$$$$,
$$$$$$$ adjustable='datalim'
$$$$$$$)
$$$$$$$``.
$$$$$$$
                     Explicit data limits may not be respected in this case.
$$$$$$$
            'scaled' Set equal scaling 
$$$$$$$
$$$$$$$(
$$$$$$$i.e.
$$$$$$$,
$$$$$$$ make circles circular
$$$$$$$)
$$$$$$$ by
$$$$$$$
                     changing dimensions of the plot box. This is the same as
                     ``ax.set_aspect
$$$$$$$
$$$$$$$(
$$$$$$$'equal'
$$$$$$$,
$$$$$$$ adjustable='box'
$$$$$$$,
$$$$$$$ anchor='C'
$$$$$$$)
$$$$$$$``.
$$$$$$$
                     Additionally
$$$$$$$
$$$$$$$,
$$$$$$$ further autoscaling will be disabled.
$$$$$$$
            'tight'  Set limits just large enough to show all data
$$$$$$$
$$$$$$$,
$$$$$$$ then
$$$$$$$
                     disable further autoscaling.
$$$$$$$
            'auto'   Automatic scaling 
$$$$$$$
$$$$$$$(
$$$$$$$fill plot box with data
$$$$$$$)
$$$$$$$.
$$$$$$$
            'image'  'scaled' with axis limits equal to data limits.
            'square' Square plot; similar to 'scaled'
$$$$$$$
$$$$$$$,
$$$$$$$ but initially forcing
$$$$$$$
                     ``xmax-xmin == ymax-ymin``.
$$$$$$$
            ======== ==========================================================
$$$$$$$

$$$$$$$
        emit 
$$$$$$$
$$$$$$$:
$$$$$$$ bool
$$$$$$$,
$$$$$$$ default
$$$$$$$:
$$$$$$$ True
$$$$$$$
            Whether observers are notified of the axis limit change.
            This option is passed on to `~.Axes.set_xlim` and
            `~.Axes.set_ylim`.
$$$$$$$

$$$$$$$
        Returns
        -------
        xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax 
$$$$$$$:
$$$$$$$ float
$$$$$$$
            The axis limits.
$$$$$$$

$$$$$$$
        See Also
        --------
        matplotlib.axes.Axes.set_xlim
        matplotlib.axes.Axes.set_ylim
        """
        if len
$$$$$$$
$$$$$$$(
$$$$$$$args
$$$$$$$)
$$$$$$$ == 1 and isinstance
$$$$$$$(
$$$$$$$args[0]
$$$$$$$,
$$$$$$$ 
$$$$$$$(
$$$$$$$str
$$$$$$$,
$$$$$$$ bool
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            s = args[0]
            if s is True
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                s = 'on'
$$$$$$$
            if s is False
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                s = 'off'
$$$$$$$
            s = s.lower
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            if s == 'on'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                self.set_axis_on
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            elif s == 'off'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                self.set_axis_off
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            elif s in 
$$$$$$$
$$$$$$$(
$$$$$$$'equal'
$$$$$$$,
$$$$$$$ 'tight'
$$$$$$$,
$$$$$$$ 'scaled'
$$$$$$$,
$$$$$$$ 'auto'
$$$$$$$,
$$$$$$$ 'image'
$$$$$$$,
$$$$$$$ 'square'
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                self.set_autoscale_on
$$$$$$$
$$$$$$$(
$$$$$$$True
$$$$$$$)
$$$$$$$
$$$$$$$
                self.set_aspect
$$$$$$$
$$$$$$$(
$$$$$$$'auto'
$$$$$$$)
$$$$$$$
$$$$$$$
                self.autoscale_view
$$$$$$$
$$$$$$$(
$$$$$$$tight=False
$$$$$$$)
$$$$$$$
$$$$$$$
                # self.apply_aspect
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
                if s == 'equal'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                    self.set_aspect
$$$$$$$
$$$$$$$(
$$$$$$$'equal'
$$$$$$$,
$$$$$$$ adjustable='datalim'
$$$$$$$)
$$$$$$$
$$$$$$$
                elif s == 'scaled'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                    self.set_aspect
$$$$$$$
$$$$$$$(
$$$$$$$'equal'
$$$$$$$,
$$$$$$$ adjustable='box'
$$$$$$$,
$$$$$$$ anchor='C'
$$$$$$$)
$$$$$$$
$$$$$$$
                    self.set_autoscale_on
$$$$$$$
$$$$$$$(
$$$$$$$False
$$$$$$$)
$$$$$$$  # Req. by Mark Bakker
$$$$$$$
                elif s == 'tight'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                    self.autoscale_view
$$$$$$$
$$$$$$$(
$$$$$$$tight=True
$$$$$$$)
$$$$$$$
$$$$$$$
                    self.set_autoscale_on
$$$$$$$
$$$$$$$(
$$$$$$$False
$$$$$$$)
$$$$$$$
$$$$$$$
                elif s == 'image'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                    self.autoscale_view
$$$$$$$
$$$$$$$(
$$$$$$$tight=True
$$$$$$$)
$$$$$$$
$$$$$$$
                    self.set_autoscale_on
$$$$$$$
$$$$$$$(
$$$$$$$False
$$$$$$$)
$$$$$$$
$$$$$$$
                    self.set_aspect
$$$$$$$
$$$$$$$(
$$$$$$$'equal'
$$$$$$$,
$$$$$$$ adjustable='box'
$$$$$$$,
$$$$$$$ anchor='C'
$$$$$$$)
$$$$$$$
$$$$$$$
                elif s == 'square'
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                    self.set_aspect
$$$$$$$
$$$$$$$(
$$$$$$$'equal'
$$$$$$$,
$$$$$$$ adjustable='box'
$$$$$$$,
$$$$$$$ anchor='C'
$$$$$$$)
$$$$$$$
$$$$$$$
                    self.set_autoscale_on
$$$$$$$
$$$$$$$(
$$$$$$$False
$$$$$$$)
$$$$$$$
$$$$$$$
                    xlim = self.get_xlim
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
                    ylim = self.get_ylim
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
                    edge_size = max
$$$$$$$
$$$$$$$(
$$$$$$$np.diff
$$$$$$$(
$$$$$$$xlim
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ np.diff
$$$$$$$(
$$$$$$$ylim
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$[0]
$$$$$$$
                    self.set_xlim
$$$$$$$
$$$$$$$(
$$$$$$$[xlim[0]
$$$$$$$,
$$$$$$$ xlim[0] + edge_size]
$$$$$$$,
$$$$$$$
$$$$$$$
                                  emit=emit
$$$$$$$
$$$$$$$,
$$$$$$$ auto=False
$$$$$$$)
$$$$$$$
$$$$$$$
                    self.set_ylim
$$$$$$$
$$$$$$$(
$$$$$$$[ylim[0]
$$$$$$$,
$$$$$$$ ylim[0] + edge_size]
$$$$$$$,
$$$$$$$
$$$$$$$
                                  emit=emit
$$$$$$$
$$$$$$$,
$$$$$$$ auto=False
$$$$$$$)
$$$$$$$
$$$$$$$
            else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$'Unrecognized string %s to axis; '
$$$$$$$
                                 'try on or off' % s
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if len
$$$$$$$
$$$$$$$(
$$$$$$$args
$$$$$$$)
$$$$$$$ >= 1
$$$$$$$:
$$$$$$$
$$$$$$$
                if len
$$$$$$$
$$$$$$$(
$$$$$$$args
$$$$$$$)
$$$$$$$ != 1
$$$$$$$:
$$$$$$$
$$$$$$$
                    cbook.warn_deprecated
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
                        "3.2"
$$$$$$$
$$$$$$$,
$$$$$$$ message="Passing more than one positional "
$$$$$$$
                        "argument to axis
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$ is deprecated and will raise a "
$$$$$$$
                        "TypeError %
$$$$$$$
$$$$$$$(
$$$$$$$removal
$$$$$$$)
$$$$$$$s."
$$$$$$$)
$$$$$$$
$$$$$$$
                limits = args[0]
                try
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                    xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax = limits
$$$$$$$
                except 
$$$$$$$
$$$$$$$(
$$$$$$$TypeError
$$$$$$$,
$$$$$$$ ValueError
$$$$$$$)
$$$$$$$ as err
$$$$$$$:
$$$$$$$
$$$$$$$
                    raise TypeError
$$$$$$$
$$$$$$$(
$$$$$$$'the first argument to axis
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$ must be an '
$$$$$$$
                                    'interable of the form '
                                    '[xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax]'
$$$$$$$)
$$$$$$$ from err
$$$$$$$
            else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                xmin = kwargs.pop
$$$$$$$
$$$$$$$(
$$$$$$$'xmin'
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$
$$$$$$$
                xmax = kwargs.pop
$$$$$$$
$$$$$$$(
$$$$$$$'xmax'
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$
$$$$$$$
                ymin = kwargs.pop
$$$$$$$
$$$$$$$(
$$$$$$$'ymin'
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$
$$$$$$$
                ymax = kwargs.pop
$$$$$$$
$$$$$$$(
$$$$$$$'ymax'
$$$$$$$,
$$$$$$$ None
$$$$$$$)
$$$$$$$
$$$$$$$
            xauto = 
$$$$$$$
$$$$$$$(
$$$$$$$None  # Keep autoscale state as is.
$$$$$$$
                     if xmin is None and xmax is None
                     else False
$$$$$$$
$$$$$$$)
$$$$$$$  # Turn off autoscale.
$$$$$$$
            yauto = 
$$$$$$$
$$$$$$$(
$$$$$$$None
$$$$$$$
                     if ymin is None and ymax is None
                     else False
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            self.set_xlim
$$$$$$$
$$$$$$$(
$$$$$$$xmin
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ emit=emit
$$$$$$$,
$$$$$$$ auto=xauto
$$$$$$$)
$$$$$$$
$$$$$$$
            self.set_ylim
$$$$$$$
$$$$$$$(
$$$$$$$ymin
$$$$$$$,
$$$$$$$ ymax
$$$$$$$,
$$$$$$$ emit=emit
$$$$$$$,
$$$$$$$ auto=yauto
$$$$$$$)
$$$$$$$
$$$$$$$
        if kwargs
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise TypeError
$$$$$$$
$$$$$$$(
$$$$$$$f"axis
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$ got an unexpected keyword argument "
$$$$$$$
                            f"'{next
$$$$$$$
$$$$$$$(
$$$$$$$iter
$$$$$$$(
$$$$$$$kwargs
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$}'"
$$$$$$$)
$$$$$$$
$$$$$$$
        return 
$$$$$$$
$$$$$$$(
$$$$$$$*self.get_xlim
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ *self.get_ylim
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_legend
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """Return the `.Legend` instance
$$$$$$$
$$$$$$$,
$$$$$$$ or None if no legend is defined."""
$$$$$$$
        return self.legend_
$$$$$$$

$$$$$$$
    def get_images
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        r"""Return a list of `.AxesImage`\s contained by the Axes."""
        return cbook.silent_list
$$$$$$$
$$$$$$$(
$$$$$$$'AxesImage'
$$$$$$$,
$$$$$$$ self.images
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_lines
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """Return a list of lines contained by the Axes."""
        return cbook.silent_list
$$$$$$$
$$$$$$$(
$$$$$$$'Line2D'
$$$$$$$,
$$$$$$$ self.lines
$$$$$$$)
$$$$$$$

$$$$$$$
    def get_xaxis
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return the XAxis instance.
$$$$$$$

$$$$$$$
        The use of this function is discouraged. You should instead directly
        access the attribute ``ax.xaxis``.
        """
        return self.xaxis
$$$$$$$

$$$$$$$
    def get_yaxis
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return the YAxis instance.
$$$$$$$

$$$$$$$
        The use of this function is discouraged. You should instead directly
        access the attribute ``ax.yaxis``.
        """
        return self.yaxis
$$$$$$$

$$$$$$$
    get_xgridlines = _axis_method_wrapper
$$$$$$$
$$$$$$$(
$$$$$$$"xaxis"
$$$$$$$,
$$$$$$$ "get_gridlines"
$$$$$$$)
$$$$$$$
$$$$$$$
    get_xticklines = _axis_method_wrapper
$$$$$$$
$$$$$$$(
$$$$$$$"xaxis"
$$$$$$$,
$$$$$$$ "get_ticklines"
$$$$$$$)
$$$$$$$
$$$$$$$
    get_ygridlines = _axis_method_wrapper
$$$$$$$
$$$$$$$(
$$$$$$$"yaxis"
$$$$$$$,
$$$$$$$ "get_gridlines"
$$$$$$$)
$$$$$$$
$$$$$$$
    get_yticklines = _axis_method_wrapper
$$$$$$$
$$$$$$$(
$$$$$$$"yaxis"
$$$$$$$,
$$$$$$$ "get_ticklines"
$$$$$$$)
$$$$$$$

$$$$$$$
    # Adding and tracking artists
$$$$$$$

$$$$$$$
    def _sci
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ im
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Set the current image.
$$$$$$$

$$$$$$$
        This image will be the target of colormap functions like
        `~.pyplot.viridis`
$$$$$$$
$$$$$$$,
$$$$$$$ and other functions such as `~.pyplot.clim`.  The
$$$$$$$
        current image is an attribute of the current axes.
        """
        if isinstance
$$$$$$$
$$$$$$$(
$$$$$$$im
$$$$$$$,
$$$$$$$ mpl.contour.ContourSet
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            if im.collections[0] not in self.collections
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$"ContourSet must be in current Axes"
$$$$$$$)
$$$$$$$
$$$$$$$
        elif im not in self.images and im not in self.collections
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            raise ValueError
$$$$$$$
$$$$$$$(
$$$$$$$"Argument must be an image
$$$$$$$,
$$$$$$$ collection
$$$$$$$,
$$$$$$$ or "
$$$$$$$
                             "ContourSet in this Axes"
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self._current_image = im
$$$$$$$

$$$$$$$
    def _gci
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
        return self._current_image
$$$$$$$

$$$$$$$
    def has_data
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Return whether any artists have been added to the axes.
$$$$$$$

$$$$$$$
        This should not be used to determine whether the *dataLim*
        need to be updated
$$$$$$$
$$$$$$$,
$$$$$$$ and may not actually be useful for
$$$$$$$
        anything.
        """
        return 
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$
            len
$$$$$$$
$$$$$$$(
$$$$$$$self.collections
$$$$$$$)
$$$$$$$ +
$$$$$$$
            len
$$$$$$$
$$$$$$$(
$$$$$$$self.images
$$$$$$$)
$$$$$$$ +
$$$$$$$
            len
$$$$$$$
$$$$$$$(
$$$$$$$self.lines
$$$$$$$)
$$$$$$$ +
$$$$$$$
            len
$$$$$$$
$$$$$$$(
$$$$$$$self.patches
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$ > 0

$$$$$$$
    def add_artist
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ a
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Add an `~.Artist` to the axes
$$$$$$$
$$$$$$$,
$$$$$$$ and return the artist.

$$$$$$$
        Use `add_artist` only for artists for which there is no dedicated
        "add" method; and if necessary
$$$$$$$
$$$$$$$,
$$$$$$$ use a method such as `update_datalim`
$$$$$$$
        to manually update the dataLim if the artist is to be included in
        autoscaling.
$$$$$$$

$$$$$$$
        If no ``transform`` has been specified when creating the artist 
$$$$$$$
$$$$$$$(
$$$$$$$e.g.
$$$$$$$
        ``artist.get_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$ == None``
$$$$$$$)
$$$$$$$ then the transform is set to
$$$$$$$
        ``ax.transData``.
        """
        a.axes = self
        self.artists.append
$$$$$$$
$$$$$$$(
$$$$$$$a
$$$$$$$)
$$$$$$$
$$$$$$$
        a._remove_method = self.artists.remove
        self._set_artist_props
$$$$$$$
$$$$$$$(
$$$$$$$a
$$$$$$$)
$$$$$$$
$$$$$$$
        a.set_clip_path
$$$$$$$
$$$$$$$(
$$$$$$$self.patch
$$$$$$$)
$$$$$$$
$$$$$$$
        self.stale = True
        return a
$$$$$$$

$$$$$$$
    def add_child_axes
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ ax
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Add an `~.AxesBase` to the axes' children; return the child axes.
$$$$$$$

$$$$$$$
        This is the lowlevel version.  See `.axes.Axes.inset_axes`.
        """
$$$$$$$

$$$$$$$
        # normally axes have themselves as the axes
$$$$$$$
$$$$$$$,
$$$$$$$ but these need to have
$$$$$$$
        # their parent...
        # Need to bypass the getter...
        ax._axes = self
        ax.stale_callback = martist._stale_axes_callback
$$$$$$$

$$$$$$$
        self.child_axes.append
$$$$$$$
$$$$$$$(
$$$$$$$ax
$$$$$$$)
$$$$$$$
$$$$$$$
        ax._remove_method = self.child_axes.remove
        self.stale = True
        return ax
$$$$$$$

$$$$$$$
    def add_collection
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ collection
$$$$$$$,
$$$$$$$ autolim=True
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Add a `~.Collection` to the axes' collections; return the collection.
        """
        label = collection.get_label
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if not label
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            collection.set_label
$$$$$$$
$$$$$$$(
$$$$$$$'_collection%d' % len
$$$$$$$(
$$$$$$$self.collections
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.collections.append
$$$$$$$
$$$$$$$(
$$$$$$$collection
$$$$$$$)
$$$$$$$
$$$$$$$
        collection._remove_method = self.collections.remove
        self._set_artist_props
$$$$$$$
$$$$$$$(
$$$$$$$collection
$$$$$$$)
$$$$$$$

$$$$$$$
        if collection.get_clip_path
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$ is None
$$$$$$$:
$$$$$$$
$$$$$$$
            collection.set_clip_path
$$$$$$$
$$$$$$$(
$$$$$$$self.patch
$$$$$$$)
$$$$$$$

$$$$$$$
        if autolim
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            # Make sure viewLim is not stale 
$$$$$$$
$$$$$$$(
$$$$$$$mostly to match
$$$$$$$
            # pre-lazy-autoscale behavior
$$$$$$$
$$$$$$$,
$$$$$$$ which is not really better
$$$$$$$)
$$$$$$$.
$$$$$$$
            self._unstale_viewLim
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            datalim = collection.get_datalim
$$$$$$$
$$$$$$$(
$$$$$$$self.transData
$$$$$$$)
$$$$$$$
$$$$$$$
            points = datalim.get_points
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
            if not np.isinf
$$$$$$$
$$$$$$$(
$$$$$$$datalim.minpos
$$$$$$$)
$$$$$$$.all
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                # By definition
$$$$$$$
$$$$$$$,
$$$$$$$ if minpos 
$$$$$$$(
$$$$$$$minimum positive value
$$$$$$$)
$$$$$$$ is set
$$$$$$$
                # 
$$$$$$$
$$$$$$$(
$$$$$$$i.e.
$$$$$$$,
$$$$$$$ non-inf
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ then min
$$$$$$$(
$$$$$$$points
$$$$$$$)
$$$$$$$ <= minpos <= max
$$$$$$$(
$$$$$$$points
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$
$$$$$$$
                # and minpos would be superfluous. However
$$$$$$$
$$$$$$$,
$$$$$$$ we add minpos to
$$$$$$$
                # the call so that self.dataLim will update its own minpos.
                # This ensures that log scales see the correct minimum.
                points = np.concatenate
$$$$$$$
$$$$$$$(
$$$$$$$[points
$$$$$$$,
$$$$$$$ [datalim.minpos]]
$$$$$$$)
$$$$$$$
$$$$$$$
            self.update_datalim
$$$$$$$
$$$$$$$(
$$$$$$$points
$$$$$$$)
$$$$$$$

$$$$$$$
        self.stale = True
        return collection
$$$$$$$

$$$$$$$
    def add_image
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ image
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Add an `~.AxesImage` to the axes' images; return the image.
        """
        self._set_artist_props
$$$$$$$
$$$$$$$(
$$$$$$$image
$$$$$$$)
$$$$$$$
$$$$$$$
        if not image.get_label
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            image.set_label
$$$$$$$
$$$$$$$(
$$$$$$$'_image%d' % len
$$$$$$$(
$$$$$$$self.images
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.images.append
$$$$$$$
$$$$$$$(
$$$$$$$image
$$$$$$$)
$$$$$$$
$$$$$$$
        image._remove_method = self.images.remove
        self.stale = True
        return image
$$$$$$$

$$$$$$$
    def _update_image_limits
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ image
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        xmin
$$$$$$$
$$$$$$$,
$$$$$$$ xmax
$$$$$$$,
$$$$$$$ ymin
$$$$$$$,
$$$$$$$ ymax = image.get_extent
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.axes.update_datalim
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$(
$$$$$$$xmin
$$$$$$$,
$$$$$$$ ymin
$$$$$$$)
$$$$$$$
$$$$$$$,
$$$$$$$ 
$$$$$$$(
$$$$$$$xmax
$$$$$$$,
$$$$$$$ ymax
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
    def add_line
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ line
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Add a `.Line2D` to the axes' lines; return the line.
        """
        self._set_artist_props
$$$$$$$
$$$$$$$(
$$$$$$$line
$$$$$$$)
$$$$$$$
$$$$$$$
        if line.get_clip_path
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$ is None
$$$$$$$:
$$$$$$$
$$$$$$$
            line.set_clip_path
$$$$$$$
$$$$$$$(
$$$$$$$self.patch
$$$$$$$)
$$$$$$$

$$$$$$$
        self._update_line_limits
$$$$$$$
$$$$$$$(
$$$$$$$line
$$$$$$$)
$$$$$$$
$$$$$$$
        if not line.get_label
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            line.set_label
$$$$$$$
$$$$$$$(
$$$$$$$'_line%d' % len
$$$$$$$(
$$$$$$$self.lines
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        self.lines.append
$$$$$$$
$$$$$$$(
$$$$$$$line
$$$$$$$)
$$$$$$$
$$$$$$$
        line._remove_method = self.lines.remove
        self.stale = True
        return line
$$$$$$$

$$$$$$$
    def _add_text
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ txt
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Add a `~.Text` to the axes' texts; return the text.
        """
        self._set_artist_props
$$$$$$$
$$$$$$$(
$$$$$$$txt
$$$$$$$)
$$$$$$$
$$$$$$$
        self.texts.append
$$$$$$$
$$$$$$$(
$$$$$$$txt
$$$$$$$)
$$$$$$$
$$$$$$$
        txt._remove_method = self.texts.remove
        self.stale = True
        return txt
$$$$$$$

$$$$$$$
    def _update_line_limits
$$$$$$$
$$$$$$$(
$$$$$$$self
$$$$$$$,
$$$$$$$ line
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
        """
        Figures out the data limit of the given line
$$$$$$$
$$$$$$$,
$$$$$$$ updating self.dataLim.
$$$$$$$
        """
        path = line.get_path
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
        if path.vertices.size == 0
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            return
$$$$$$$

$$$$$$$
        line_trans = line.get_transform
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$

$$$$$$$
        if line_trans == self.transData
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            data_path = path
$$$$$$$

$$$$$$$
        elif any
$$$$$$$
$$$$$$$(
$$$$$$$line_trans.contains_branch_seperately
$$$$$$$(
$$$$$$$self.transData
$$$$$$$)
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
            # identify the transform to go from line's coordinates
            # to data coordinates
            trans_to_data = line_trans - self.transData
$$$$$$$

$$$$$$$
            # if transData is affine we can use the cached non-affine component
            # of line's path. 
$$$$$$$
$$$$$$$(
$$$$$$$since the non-affine part of line_trans is
$$$$$$$
            # entirely encapsulated in trans_to_data
$$$$$$$
$$$$$$$)
$$$$$$$.
$$$$$$$
            if self.transData.is_affine
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                line_trans_path = line._get_transformed_path
$$$$$$$
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
                na_path
$$$$$$$
$$$$$$$,
$$$$$$$ _ = line_trans_path.get_transformed_path_and_affine
$$$$$$$(
$$$$$$$
$$$$$$$)
$$$$$$$
$$$$$$$
                data_path = trans_to_data.transform_path_affine
$$$$$$$
$$$$$$$(
$$$$$$$na_path
$$$$$$$)
$$$$$$$
$$$$$$$
            else
$$$$$$$
$$$$$$$:
$$$$$$$
$$$$$$$
                data_path = trans_to_data.transform_path
$$$$$$$
$$$$$$$(
$$$$$$$path
$$$$$$$)
